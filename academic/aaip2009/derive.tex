\documentclass[preprint,draft]{sigplanconf}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{multirow}
\usepackage{setspace}
\usepackage{balance}

\include{paper}

%include paper.fmt
%format `k` = "\backtick{k}"

\newcommand{\derive}{\textsc{Derive}}

\hsdef{\begin{comment}
Show,Enum,Ord,Bounded,Serial,Arbitrary,Monoid,Binary,Functor
ShowOrd,Either,Typeable,Invalid
alpha,beta,d_1,d_2,Q,Append,i,f
\end{comment}}
\begin{comment}
\h{.default .two}\begin{code}
import Data.Data
import Data.List
import Language.Haskell.Exts hiding (Int,String,App,List)
import Data.Monoid hiding (First)
import Control.Parallel.Strategies

data Version; instance NFData Version
data Extension; instance NFData Extension
data Compiler; instance NFData Compiler

class Arities a where arities :: a -> [Int]
derive' :: Output -> [DSL]
(~==) :: DSL -> DSL -> Bool
instance Typeable1 Sample
instance Eq Output
instance Eq (Input -> Output)
\end{code}
\h{.hse}\begin{code}
import Language.Haskell.Exts
import Data.Generics.PlateData
\end{code}
\end{comment}

\begin{document}

\conferenceinfo{3rd workshop on Approaches and Applications of Inductive Programming}{4th September 2009, Edinburgh.} %
\copyrightyear{2009} %
\copyrightdata{[to be supplied]}

\titlebanner{\today{} - \currenttime{}}        % These are ignored unless
\preprintfooter{}   % 'preprint' option specified.

\title{Deriving a DSL from One Example}
% \subtitle{}

\authorinfo{Neil Mitchell}
           {Standard Chartered, UK}
           {\verb"ndmitchell@gmail.com"}

\maketitle

\begin{abstract}
Given an appropriate domain specific language (DSL), it is possible to describe the relationship between Haskell data types and many generic functions, typically type class instances. While describing the relationship is possible, it is not always an easy task. There is an alternative -- simply give one example output for a carefully chosen input, and have the relationship derived.

When deriving a relationship from only one example, it is important that the derived relationship is the intended one. We identify general restrictions on the DSL, and on the provided example, to ensure a level of predictability. We then apply these restrictions in practice, to derive the relationship between Haskell data types and generic functions. We have used our scheme in the Derive tool, where 60\% of type classes are derived from a single example.
\end{abstract}

\category{D.3}{Software}{Programming Languages}

\terms
Languages

\keywords
Haskell, Domain Specific Languages

\section{Introduction}
\label{sec:introduction}

In Haskell \cite{haskell}, \textit{type classes} \cite{wadler:type_classes} are used to provide similar operations for many data types. For each data type of interest, a user must define an appropriate instance. The instance definitions usually follow a highly regular pattern. Many libraries define new type classes, for example \citet{trinder:strategies} define the |NFData| type class, which reduces a value to normal form. As an example, we can define a data type to describe some computer programming languages, and provide an |NFData| instance:

\begin{code}
data Language  =  Haskell [Extension] Compiler
               |  Whitespace
               |  Java Version

instance NFData Language where
    rnf (Haskell x_1 x_2  ) = rnf x_1 `seq` rnf x_2 `seq` ()
    rnf (Whitespace       ) = ()
    rnf (Java x_1         ) = rnf x_1 `seq` ()
\end{code}

We also need to define |NFData| instances for the data types |Extension|, |Compiler| and |Version|. Any instance of |NFData| follows naturally from the structure of a data type: for each constructor, all fields have |seq| applied before, returning |()|.

Writing an |NFData| instance for one data type is simple -- but the effort required increases as the data types get more complex and numerous. The standard solution is to express the \textit{relationship} between a data type and associated instance. In standard tools such as DrIFT \cite{drift}, the person describing the relationship must be familiar with both the representation of a data type, and various code-generation functions. The result is that specifying the relationship is not as straightforward as one might hope.

\begin{figure}
\h{.default .two}\begin{code}
data Sample alpha  =  First
                   |  Second  alpha alpha
                   |  Third   alpha
\end{code}
\caption{The |Sample| data type.}
\label{fig:sample}
\end{figure}

Using the techniques described in this paper, these relationships can often be automatically inferred from a single example. To define the relationship for \textit{all} |NFData| instances, we require an example to be given for the |Sample| data type defined in Figure~\ref{fig:sample}:

\begin{code}
instance NFData alpha => NFData (Sample alpha) where
    rnf (First           ) = ()
    rnf (Second x_1 x_2  ) = rnf x_1 `seq` rnf x_2 `seq` ()
    rnf (Third x_1       ) = rnf x_1 `seq` ()
\end{code}

The |NFData| instance for |Sample| follows the same pattern as for |Language|. From this single example, we can infer the relationship. However, there are many possible relationships between the data type and the result -- for example the function might always generate the instance for |Sample|, regardless of the input type. We overcome this problem by requiring that the relationship be written in a domain specific language (DSL), and that the example has certain properties (see \S\ref{sec:scheme}). With our restrictions, we can regain predictability.

\subsection{Contributions}

This paper makes the following contributions:

\begin{itemize}
\item We describe a scheme which allows us to infer predictable and correct relationships (\S\ref{sec:scheme}).
\item We describe how this scheme is applicable to instance generation, both in a high-level manner (\S\ref{sec:instances}), and more detailed practical concerns (\S\ref{sec:implementation}).
\item We outline a method for deriving a relationship in our DSL, without resorting to unguided search (\S\ref{sec:guess}).
\item We give measured results (\S\ref{sec:results}), including reasons why our inference fails (\S\ref{sec:failure}). In our experience, over 60\% of Haskell class instances can be determined using this technique.
\end{itemize}

\section{Our Derivation Scheme}
\label{sec:scheme}

In this section we define a general derivation scheme, relating inputs to outputs, which we can later use in our specific example of type class instance derivation. In general terms, a function takes an input to an output. In our case, we restrict functions to only those that can be described by a DSL. Therefore, we need a function to serve as an interpreter for our DSL (which we call |apply|), which takes an input and a DSL and produces an output. Our scheme can be implemented in Haskell as follows:

\h{.short}\begin{code}
data Input
data Output
data DSL

apply :: DSL -> Input -> Output
\end{code}

Now we consider our derivation scheme. Given a single result of the |Output| type, for a particular |Input| sample, we want to derive a particular DSL. However, we may not always be able to derive an appropriate DSL, so our derivation function must allow the possibility of failure. Instead of maybe producing a single DSL result, we instead choose to produce a list of DSL results, following the lead of \citet{wadler:list_of_successes}. Once again, we can implement this in Haskell as:

\begin{code}
sample :: Input
derive :: Output -> [DSL]
\end{code}

We require our scheme to have two particular properties -- correctness (it works) and predictability (its what the user intended). We now define each of these properties more formally, along with the necessary restrictions to achieve them in general.

\subsection{Correctness}
\label{sec:correctness}

A guess is correct if all derived DSL's, when applied to the sample input, produce the given output:

\ignore\begin{code}
forall d `elem` derive output `o` apply d sample == output
\end{code}

Given an arbitrary |derive'| function, which does not necessarily ensure correctness, it is easy to write a wrapper which is guaranteed correct, by simply filtering out the incorrect DSL's. By using a wrapper, we can remove some constraints from the |derive'| function -- either simplifying the implementation, or gaining a higher assurance of correctness.

\begin{code}
derive output =
    [d | d <- derive' output, apply d sample == output]
\end{code}

\subsection{Predictability}

We define two DSL's to be congruent |(~==)|, if for each input they both produce the same result -- i.e. |apply d_1 == apply d_2|.

\ignore\begin{code}
d_1 ~== d_2 = forall i `elem` Input `o` apply d_1 i == apply d_2 i
\end{code}

Our |derive| function returns a list of possible DSL's. In order to ensure predictability, it is important that all the possible DSL's are congruent -- meaning that we can pick any as the DSL denoting the relationship.

\ignore\begin{code}
forall d_1,d_2 `elem` derive output `o` d_1 ~== d_2
\end{code}

Unfortunately, this property is very dependent on the |derive| function. Given two different implementations of |derive|, which produce different (but still correct) relationships for a particular example, the user would have lost predictability. Therefore, we require a stronger property to ensure predictability. Not only must all results from |derive| be congruent, but all results satisfying the correctness property must be congruent:

\ignore\begin{code}
forall d_1, d_2 `elem` DSL `o`
    apply d_1 sample == apply d_2 sample => d_1 ~== d_2
\end{code}

It is important that the predictability lemma does require any conditions on |derive|, although it may require a specially chosen |sample| value. To prove the predictability property does not require knowledge of the |derive| function, and can be proven given a particular DSL and sample value.

\subsection{Summary}

If the predictability property holds for the DSL and sample value, and we use the modified |derive| in terms of |derive'|, then any result produced by |derive| will be a valid relationship. These properties allow us to write the |derive| function without regard to correctness, focusing on other attributed (which we discuss in \S\ref{sec:guess}).

To use this general scheme, we need to instantiate it to our particular problem (\S\ref{sec:instances}), prove the predictability property (\S\ref{sec:predictability}), and implement a |derive| function (\S\ref{sec:guess}).

\section{Deriving Instances}
\label{sec:instances}

In this section we apply the scheme from the previous section to the problem of deriving type class instances. We let the output type be Haskell source code and the input type by a representation of algebraic data types. The DSL contains features such as list manipulation, constant values, folds and maps. We first describe each type in detail, then discuss the restrictions necessary to satisfy the predictability property.

\subsection{Output}

We wish to allow generation of any sequence of Haskell declarations, where a declaration is typically a function definition or type class instance. There are several possible types to represent a sequence of declarations:

\begin{description}
\item[String] A sequence of Haskell declarations can be represented as the string corresponding to the program text. However, the lack of structure in a string poses several problems. When constructing strings it is easy to generate invalid programs, particular given the indentation and layout of Haskell. It is also hard to recover structure from the program that is likely to be useful for deriving relationships.
\item[Pretty printing combinators] Some tools such as DrIFT \cite{drift} generate Haskell code using pretty printing combinators. These combinators supply more structure than strings, but the structure is linked to the presentation, rather than the meaning of constructs.
\item[Typed abstract syntax tree (AST)] The standard way of working with Haskell source code is using a typed AST -- an AST where different types of fragment (i.e. declarations, expressions and patterns) are restricted to different positions in the tree. The first version of \derive{} used a typed AST, specifically Template Haskell \cite{template_haskell}. This approach preserves all the structure, and makes it reasonably easy to ensure the generated program is syntactically valid. By combining a typed AST with a parser and pretty printer we can convert to strings where necessary.
\item[Untyped abstract syntax tree (AST)] An untyped AST is an AST where all fragments have the same type, and types do not restrict where a fragment may be placed. The removal of types increases the number of invalid programs that can be written -- for example a pattern could occur when a declaration was expected. However, by removing the types we increase the similarity of the tree, in turn simplifying operations that wish to operate on the tree in a uniform manner.
\end{description}

For our purposes, it is clear that both string and pretty printing combinators are unsuitable -- they lack sufficient structure to implement the |derive| operation. The choice between a typed and untyped AST is one of safety vs simplicity. The use of a typed AST in the first version of \derive{} caused several complexities -- notably the DSL was hard to represent in a well-typed manner and some functions had to be duplicated for each type. The loss of safety from untyped AST's is not great, because both DSL's and AST's are automatically generated, rather than being written by hand. Therefore, we chose to use untyped AST's for the current version of \derive{}. We discuss possible changes to regain type safety in \S\ref{sec:conclusion}.

While we work internally with an untyped AST, most existing Haskell libraries for working with AST's are type, therefore we choose to take a typed AST and collapse it to a single type (details of how this is done are in \S\ref{sec:universe}). The use of Template Haskell in the first version of \derive{} gave a number of advantages -- it is built in to GHC and can represent a large range of Haskell programs. Unfortunately, there were also a number of problems:

\begin{itemize}
\item While being tied to GHC ensures Template Haskell is available everywhere GHC is, it means that Template Haskell cannot be upgraded separately. Users of older versions of GHC cannot take advantage of improvements in Template Haskell, and every GHC upgrade requires changes to fix \derive{}.
\item Template Haskell does not track the extensions in GHC very well -- it is usually several point releases behind. For example, Template Haskell does not yet support view patterns.
\item While Template Haskell provides nice integration for the generation of instances combined directly into GHC programs, it makes the construction of a standalone preprocessor harder. While there are ways round this problem, they are fragile.
\item If Template Haskell is also used to read the input data type (as it is the first version of \derive{}) then only data types contained in compilable modules can be used. In particular, all necessary libraries must be compiled before an instance can be generated.
\item The API of Template Haskell is relatively complex, and has some inconsistencies. In particular the use of the |Q| monad caused much frustration.
\end{itemize}

We choose to base the current version of \derive{} on haskell-src-exts \cite{haskell_src_exts}. The haskell-src-exts library is well maintained, supports most Haskell extensions \footnote{Haskell-src-exts supports even more extensions than GHC!} and operates purely as a library. We used the type AST in haskell-src-exts to translate to a universal data type. Our universal data type is:

\h{.default .two}\begin{code}
data Output  =  OString String
             |  OInt Int
             |  OList [Output]
             |  OApp String [Output]
\end{code}

Here |OString| and |OInt| represent concrete terminals. The |OList| constructor generates a list from a sequence of  |Output| values. The most interesting constructor is |OApp|, which constructs a value in the typed tree. For example |Just [1,2]| would be represented as |OApp "Just" [OList [OInt 1,OInt 2]]|.

Our |Output| type can represent many impossible values, for example |OApp "Just" []| is an error, as is |OApp "Invalid" []|, where |Invalid| it not a constructor. We consider any |Output| value that does not have a corresponding haskell-src-exts value to be an error. The root |Output| value must have type |[Decl]| when translated, i.e. must be an |OList|, and the inner values must have appropriate types.

\subsection{Input}

While the output type is largely dictated by the necessity to generate Haskell, we have much more freedom over the input type. The input type represents Haskell data types, but we can choose which details to provide, which in turn impacts on which possible relationships we can represent. For example, we can choose to include the module name in which the data type is defined in, or we can choose to omit this detail. We choose not too, however this does eliminate some derivations, for example the |Typeable| type class \cite{lammel:syb}.

Our |Input| type represents algebraically constructed Haskell data types. We include details such as the arity of each constructor (|ctorArity|), the 0-based index of each constructor (|ctorIndex|) and the number of type variables (|dataVars|), but omit details such as types and record field names. Our |Input| type is:

\h{.default .two}\begin{code}
data Input = Input
    {dataName :: String, dataVars :: Int, dataCtors :: [Ctor]}
data Ctor = Ctor
    {ctorName :: String, ctorIndex :: Int, ctorArity :: Int}
\end{code}

\noindent Values of |Input| for the |Sample| data type (Figure \ref{fig:sample}) and the |Language| data type (\S\ref{sec:introduction}) are:

\begin{code}
languageType :: Input
languageType = Input "Language" 0
    [Ctor "Haskell" 0 2
    ,Ctor "Whitespace" 1 0
    ,Ctor "Java" 2 1]

sampleType :: Input
sampleType = Input "Sample" 1
    [Ctor "First" 0 0
    ,Ctor "Second" 1 2
    ,Ctor "Third" 2 1]
\end{code}

The |Input| constructor records the name of the data type, and the number of type variables the data type takes. For each constructor we record the name, 0-based index, and arity. These choices allow derivations to depend on the arity or index of a constructor, but not the types of the constructors arguments. In \S\ref{sec:extensions} we describe possible extensions to increase the range of derivations that can be represented.

\subsection{DSL}

\begin{figure}
\h{.default .two}\begin{code}
data DSL
       -- Constants
    =  String String
    |  Int Int
    |  List [DSL]
    |  App String DSL{-|[alpha]|-}
       -- Operations
    |  Concat DSL{-|[[alpha]]|-}
    |  Reverse DSL{-|[alpha]|-}
    |  ShowInt DSL{-|Int|-}
       -- Fold
    |  Fold DSL DSL
    |  Head
    |  Tail
       -- Constructors
    |  MapCtor DSL
    |  CtorIndex
    |  CtorArity
    |  CtorName
       -- Fields
    |  MapField DSL
    |  FieldIndex
       -- Custom
    |  DataName
    |  Application DSL{-|[Exp]|-}
    |  Instance [String] String DSL{-|[InstDecl]|-}
\end{code}
\caption{DSL data type}
\label{fig:dsl}
\end{figure}

\begin{figure}
\begin{code}
apply :: DSL -> Input -> Output
apply dsl input = applyEnv dsl Env{envInput=input}

data Env = Env  {envInput :: Input
                ,envCtor :: Ctor
                ,envField :: Int
                ,envFold :: (Output,Output) }

applyEnv :: DSL -> Env -> Output
applyEnv dsl env@(Env input ctor field fold) = f dsl
    where
    vars = take (dataVars input) $ map (:[]) ['a'..]

    f (Instance ctx hd body) =
        OApp "InstDecl"
            [out
                [ClassA (UnQual $ Ident c) [TyVar $ Ident v]
                | v <- vars, c <- ctx]
            , out $ UnQual $ Ident hd
            , out [foldl TyApp
                (TyCon $ UnQual $ Ident $ dataName input)
                [TyVar $ Ident v | v <- vars]]
            , f body]

    f (Application (f -> OList xs)) =
        foldl1 (\a b -> OApp "App" [a,b]) xs

    f (MapCtor   dsl) = OList [applyEnv dsl env{envCtor=c   }
         | c <- dataCtors input]
    f (MapField  dsl) = OList [applyEnv dsl env{envField=i  }
         | i <- [1.. ctorArity ctor]]

    f DataName    = OString  $ dataName input
    f CtorName    = OString  $ ctorName ctor
    f CtorArity   = OInt     $ ctorArity ctor
    f CtorIndex   = OInt     $ ctorIndex ctor
    f FieldIndex  = OInt     $ field

    f Head  = fst  fold
    f Tail  = snd  fold
    f (Fold cons (f -> OList xs)) =
        foldr1 (\a b -> applyEnv cons env{envFold=(a,b)}) xs

    f (List xs) = OList $ map f xs
    f (Reverse        (f -> OList xs  )) = OList $ reverse xs
    f (Concat         (f -> OList []  )) = OList []
    f (Concat         (f -> OList xs  )) = foldr1 g xs
            where  g (OList    x) (OList    y) = OList    (x++y)
                   g (OString  x) (OString  y) = OString  (x++y)
    f (String x) = OString x
    f (Int x) = OInt x
    f (ShowInt (f -> OInt x)) = OString $ show x
    f (App x (f -> OList ys)) = OApp x ys

-- for information on |out|, see \S\ref{sec:universe}
out :: Data alpha => alpha -> Output
\end{code}
\caption{The |apply| function.}
\label{fig:apply}
\end{figure}

Our DSL type is given in Figure \ref{fig:dsl}, and our |apply| function is given in Figure \ref{fig:apply}. The operations in the DSL are split into six groups -- we first give a high-level overview of the DSL, then return to each group in detail. The |apply| function is written in terms of |applyEnv|, where an environment is passed including the input data type, and perhaps a constructor in scope. Some functions in the DSL add to the environment (i.e. |MapCtor|), while some read from the environment (i.e. |CtorName|). Any operation reading a particular value from the environment must be nested within an operation placing that value in the environment.

Some operations operate only on particular types -- for example |Reverse| requires the it's argument to evaluate to |OList|. Where possible we have annotated these type restrictions in the |DSL| definition with comments. We have used view patterns, as implemented in GHC 6.10 \cite{ghc_610}, to perform matches on the evaluated argument DSLs. Our use of view patterns can be understood with the simple translation\footnote{View-patterns and pattern-guards in GHC have different fall-through semantics, but this difference does not effect our function.}:

\ignore\begin{code}
f (Reverse (f -> OList xs)) = ...
    ==
f (Reverse v_1) | OList xs <- f v_1 = ...
    ==
f (Reverse v_1) = case f v_1 of OList xs -> ...
\end{code}

Operations have restrictions on what value inner operations must be evaluate to, and what environment values must be available. It would be possible to capture many of these invariants using either phantom types \cite{phantom_types} or GADTs \cite{spj:gadt}. However, for simplicity, we choose not to.

\subsubsection{Constants}

It is useful to represent constants in our DSL, so we can lift values of |Output| in to values of |DSL|. The |String|, |Int|, |List| operations are directly equivalent to the corresponding |Output| values. The |App| constructor is similar to |OApp|, but instead of taking a \textit{list} of arguments, |App| takes a single argument, which is required to evaluate to an |OList|. Requiring an |OList| rather than an explicit list allows the arguments to |App| to be constructed by operations such as |Reverse| or |Concat|.

\subsubsection{Operations}

The operations group are useful functions for manipulating lists, strings and integers. The operations have been added as they are required, based on functions in the Haskell Prelude. The |Concat| operation corresponds to |concat|, and concatenates either a list of lists, or a list of strings. The |Reverse| operation performs |reverse| on a list. The |ShowInt| operation performs |show|, converting an integer to a string. We have tried to provide the minimal set of operations, for example while |Reverse| could also reverse a string, we have not needed this functionality, so have left it unspecified. These operations are all simple, and would be appropriate for many DSLs. Note that we do not provide an append or |(++)| operation, but one can be created from |List| and |Concat|.

Some examples of these operations in use are:

\h{exprlist}\begin{code}
Concat (List [String "hello ", String "world"])
    == OString "hello world"
Reverse (List [Int 1, Int 2, Int 3])
    == OList [OInt 3, OInt 2, OInt 1]
ShowInt (Int 42) == OString "42"
\end{code}

\subsubsection{Fold}

The |Fold| operation implements a |foldr1|, but can be combined with |Reverse| to simulate a |foldl1|. The first argument to the |Fold| constructor is the function -- a DSL containing |Head| and |Tail| operations. The second argument must evaluate to a list of at least one element. If the list has exactly one element, that is the result. If there is more than one result, then the |Head| is replaced with the first element, and the |Tail| is replaced with the fold over the remaining elements. This can be described by:

\ignore\begin{code}
Fold fn [x] = x
Fold fn (x:xs) = fn[x / Head, Fold fn xs / Tail]
\end{code}

For example, to implement |concat| in terms of an |Append| operation would be \ignore|Fold (Append Head Tail)| (ignoring the case of an empty list). The fold operation is more complicated than the previous operations, but may still be useful to other DSLs.

\subsubsection{Constructors}

To insert information from constructors we provide |MapCtor|. This operation generates a list, with the argument DSL evaluated once with each different constructor in the environment. The argument to |MapCtor| may contain |CtorName|, |CtorIndex| and |CtorArity| operations, which retrieve the information associated with the constructor. |CtorName| produces a string, while the others produce an integer. An example of |MapCtor| on the |Sample| data type is:

\h{exprlist}\begin{code}
MapCtor CtorName == OList
    [OString "First", OString "Second", OString "Third"]
\end{code}

\subsubsection{Fields}

The |MapField| operation is similar to |MapCtor|, it maps over each field within a constructor. The operation is only valid within a |MapCtor|. Within a |MapField|, the |FieldIndex| operation returns the 1-based index of the current field. While most indexing in Haskell is 0-based, fields usually correspond to indexes on variables, which seem more natural when 1-based. As an example, with |Second| as the constructor in the environment:

\h{exprlist}\begin{code}
Concat (List [List [CtorName],
    MapField (Concat (List [String "v", ShowInt FieldIndex]))])
    == ["Second","v1","v2"]
\end{code}

\subsubsection{Custom}

The final operations are all very specific to our particular problem. By simplest operation in this group is |DataName|, which returns the string corresponding to the name of the data type.

The second operation is |Application|. The haskell-src-exts library has binary application, where multiple applications are often chained. Sometimes it is useful to have a vector application operation, which we construct with the |Application| operation. Vector application is often used for calling constructors with arguments derived from |MapField|, such in combination with the example from the previous Fields subsection.

The last operation is |Instance|, and is very specific to our problem. Many instance declarations follow a common pattern. For example, given the type \h{type}|Either alpha beta|, a typical instance declaration might be:

\ignore\begin{code}
instance (Show alpha, Ord alpha, Show beta, Ord beta) =>
    ShowOrd (Either alpha beta) where ellipses
\end{code}

The pattern is that each type variable is required to be a member of a set of type classes. This pattern is captured by the |Instance| operation, whose fields detail what classes are required for each type variable (i.e. |Show| and |Ord| in this example), what the main class is (i.e. |ShowOrd|), and a DSL to generate the body. If we were to attempt to derive this pattern without a specific |Instance| operation, we would need to be able to operate over the type variables of a data type -- which we currently cannot.s

\subsection{Restrictions for predictability}
\label{sec:predictability}

In order to ensure predictability there must be no non-congruent DSL values which give equal results when applied to the sample input. Currently this invariant is violated -- consider the simple counterexample of |DataName| vs |String "Sample"|. When applied to the sample input, both will generate |OString "Sample"|, but when applied to another data  type they will generate different values. To regain predictability we impose two additional invariants on the |DSL|:

\begin{enumerate}
\item The strings |Sample|, |First|, |Second| and |Third| cannot be the suffix of any |String| operation. In the above example, the DSL |String "Sample"| would therefore be invalid.
\item All instances must be constructed with |Instance|, not created directly using |App|.
\item Within |MapCtor| we require that the argument DSL \textit{must} include |CtorName|.
\end{enumerate}

We have already seen an example of the first restriction in practice, and the second restriction has similar motivation -- to avoid making something constant when it should not be. Now let us examine the third restriction, with a practical example:

\h{.two}\begin{code}
instance Arities (Sample alpha) where
    arities _ = [0,2,1]
\end{code}

This could either infer that the |arities| function always returns |[0,2,1]|, or it returns the arity of each constructor. While a human can spot the intention, there is a potential ambiguity. Using the second restriction, we conclude that this must represent the constant operation. To derive a version returning the arities we can write:

\begin{code}
instance Arities (Sample alpha) where
    arities _ =  [  const 0 First{}
                 ,  const 2 Second{}
                 ,  const 1 Third{}]
\end{code}

While this code code may appear less efficient, any good optimiser (i.e. GHC) will generate identical code. We return to the issue of possible simplifications in \S\ref{sec:simplify}. Given that no constructor names may occur in |String| operations, and that |CtorName| must occur within every |MapCtor|, we now require that all correct |MapCtor| DSL's must be congruent. The only other possible loss of predictability is if two items could be generated within a constructor with the same value -- for example if all indexes and arities in the sample data type were equal. However, we have avoided this particular problem by ensuring that |Second| has index 1 has arity 2, while |Third| has the opposite.

\todo{Proof here? At least a better argument. Perhaps a QuickCheck?}

\section{Implementing |derive|}
\label{sec:guess}

This section covers the implementation of a |derive| function, as described in \S\ref{sec:scheme}. There are many ways write a |derive| function, our approach is merely one choice -- we hope that the scheme we have described provides ample opportunity for experimentation.

Before implementing |derive| it is useful to think about what properties are desirable. It is not necessary to guarantee correctness (see \S\ref{sec:correctness}), but our method chooses to only generate correct results. We have shown that our DSL and sample input guarantee predictability without regard to the |derive| function, provided we meet the restrictions in \S\ref{sec:predictability}, which we obey. We want our |derive| function to terminate, and ideally terminate within a reasonable time bound. Finally, we would like the |derive| function to find an answer if one exists, i.e.:

\ignore\begin{code}
forall o `elem` Output, d `elem` DSL `o` null (derive o) => apply d sample /= o
\end{code}

We are unaware of a |derive| implementation meeting this property for our problem that also performs acceptably\footnote{We believe enumerative search to a particular depth would succeed, but this method is clearly infeasible}. Our method is a trade off between runtime and success rate, with a particular desire to succeed for real-world examples.

The basis of our |derive| implementation is a parameterised guess. Each fragment of output is related to a guess -- a DSL parameterised by some aspect of the environment. For example, |OString "First"| results in the guess |CtorName| parameterised by the first constructor. Concretely, our central |Guess| type is:

\begin{code}
data Guess  =  Guess DSL
            |  GuessCtr Int DSL -- 0-based index
            |  GuessFld Int DSL -- 1-based index

derive :: Output -> [DSL]
derive o = [d | Guess d <- guess o]

guess :: Output -> [Guess]
\end{code}

Applying |guess (OString "First")| produces the resulting guess of |GuessCtr 0 CtorName|. The |GuessCtr| and |GuessFld| guesses are paramterised by either constructors or fields, and can therefore only occur within either |MapCtor| or |MapField|. The |Guess| guess is either parameterised by the entire data type, or is a constant which does not refer to the environment at all.

To generate a guess for the entire output we start by generating guesses for the leaf nodes of the |Output| value, then work upwards combining them. If at any point we see an opportunity to apply one of our custom rules (i.e. |Instance|), we do so. The important points are how we create guesses for the leaves, how we combine guesses together (always to produce a list), and where we apply our custom rules. We require that all generated guesses are correct, defined by:

\ignore\begin{code}
forall g `elem` guess output `o` applyGuess g == o
\end{code}
\begin{code}
applyGuess :: Guess -> Output
applyGuess (Guess       d) = applyEnv d
    Env{envInput=sample}
applyGuess (GuessCtr i  d) = applyEnv d 
    Env{envInput=sample,envCtor=dataCtors sample !! i}
applyGuess (GuessFld i  d) = applyEnv d
    Env{envInput=sample,envField=i}
\end{code}

\subsection{Guessing Constant Leafs}

\subsubsection{String}

To guess an |OString| value is simple -- if it has a banned suffix (i.e. a sample constructor name or the data name) we generate an appropriately parameterised guess, otherwise we use the constant string. Some examples:

\h{.exprlist}\begin{code}
OString "hello" == String "hello"
OString "Sample" == DataName
OString "First" == Guess 0 CtorName
OString "isThird" == Guess 2
    (Concat (List [String "is",CtorName]))
\end{code}

\subsubsection{Application}

The guess for an |OApp| is composed of two parts -- the name of the constructor to apply and the list of arguments. The name of the constructor in |App| always matches that in |OApp| exactly. The arguments to |App| are created by performing |guess| on the list, and wrapping the generated DSL in |App op|. The guess for |OApp| can be written as:

\begin{code}
guess (OApp op xs) = map (lift (App op)) (guess (OList xs))

lift :: (DSL -> DSL) -> Guess -> Guess
lift f (Guess       d) = Guess       (f d)
lift f (GuessCtr i  d) = GuessCtr i  (f d)
lift f (GuessFld i  d) = GuessFld i  (f d)
\end{code}

\subsubsection{Integer}

Given an integer there may be several different guesses that are suitable. An integer could be a constant, a constructor index or arity, or a field index. We can guess an |OInt| as follows:

\begin{code}
guess (OInt i) =
    [GuessFld i FieldIndex | i `elem` [1,2]] ++
    [GuessCtr 1 CtorIndex | i == 1] ++
    [GuessCtr 1 CtorArity | i == 2] ++
    [Guess (Int i)]
\end{code}

\noindent And some examples:

\h{.exprlist}\begin{code}
OInt 0 == [Guess (Int 0)]
OInt 1 == [Guess (Int 1)  , GuessFld 1 FieldIndex
                          , GuessCtr 1 CtorArity]
OInt 2 == [Guess (Int 2)  , GuessFld 2 FieldIndex
                          , GuessCtr 2 CtorIndex]
OInt 3 == [Guess (Int 3)]
\end{code}

For the guess of an |OInt| it is interesting to note that we never generate guesses for any constructors other than index 1 (i.e. |Second|) -- the reasons are explained later in \S\ref{sec:guess_lists_sequence}. We could guess alternative constructors, but they would be unnecessary.

\subsection{Lists}

Most of the complexity in guessing comes from lists. For each element of the list, we apply |guess|, then attempt to find a list of guesses, one corresponding to each element in the list, which can be collapsed into a single guess. Therefore, the problem of guessing a list is the problem of collapsing a list of guesses to a single guess. Given such a collapse function we can write:

\begin{code}
guess (OList xs) = mapMaybe collapse (mapM guess xs)

collapse :: [Guess] -> Maybe Guess
collapse xs = liftM Concat $ rules $
    map (lift (\x -> List [x])) xs
\end{code}

\begin{comment}
\begin{code}
rules :: [Guess] -> Maybe Guess
\end{code}
\end{comment}

The |mapM| function uses the list monad to generate all possible sequences of lists. The |collapse| function first lifts each guess in to a singleton list, and concatenates the result afterwards, to ensure that rules can combine adjacent elements without changing the type of the underlying DSL. The function |rules| applies three rules, returning a |Just| result if any possible sequence of rule applications reduces the list to a singleton element.

\subsubsection{Promotion}

The promotion rule changes a guess without a parameter in to one with a parameter. We can promote |Guess| to either |GuessFld| or |GuessCtr|, with any parameter value. For example |Guess d| can be promoted to either of |GuessCtr 2 d| or |GuessField 1 d|, or using any other permissible index. The promotion rule does not reduce the number of elements in the list, but allows other rules to apply, in particular the conjunction rule.

\subsubsection{Conjunction}

If two adjacent guesses have the same parameter value, they can be combined in to one guess. For example, given |GuessCtr 2 d_1| and |GuessCtr 2 d_2| we produce |GuessCtr 2 (Concat (List [d_1,d_2]))|. This rule shows the importance that each guess evaluates to a list.

\subsubsection{Sequence}
\label{sec:guess_lists_sequence}

The sequence rule introduces either |MapField| or |MapCtor| from a list of guesses. Given two adjacent guesses we can apply the rule:

\begin{code}
(GuessFld 1 d_1) (GuessFld 2 d_2)
    | applyGuess (GuessFld 2 d_1) == applyGuess (GuessFld 2 d_2)
    = GuessCtr 1 (MapField d_1)
\end{code}

The important points are that the guesses of the fields in the correct order, one of the DSL values (in this case |d_1|) is applicable to both problems, and that the resultant guess is paramterised by the |Second| constructor, which has two fields. We also permit sequences in reverse order, which we generate by reversing the list before generating a sequence and inserting a |Reverse| afterwards.

The sequence construction for fields can be extended to constructors by demanding three guesses parameterised by consecutive constructors. For constructors we always try to use the DSL relating to the |Second| constructor, as this DSL is the only one that can possibly have a |MapField| construct within it, and we avoid generating |CtorArity| and |CtorIndex| guesses for any other constructor. In addition we also require that before creating a |MapCtor| the guess contains a |CtorName|, to ensure the restrictions from \S\ref{sec:predictability} are met.

\subsection{Folds}

The introduction of folds is 

We insert folds in a very restricted manner. 

We search for folds on an ad-hoc basis. They are quite restricted, must start |OApp m [OApp m [x,op,y],op,z]| or the flipped variant. When searching for folds we find the fold, then try and generate a list for the bits we extract. We do this in parallel.

\subsection{Application}

We search for applications in parallel, then try and infer the list.

\subsection{Instance}

We look for instances alone, and if an instance matches we do nothing else. It's dull code, but simple.



\section{Implementation Details}
\label{sec:implementation}

\subsection{Typed AST to Untyped AST}s
\label{sec:universe}

SYB stuff goes in here. Haskell-src-exts.

We skip src loc in haskell-src-exts, as it's irrelevant.

We also convert back.

\subsection{DSL Optimisation}

\subsection{Output Optimisation}
\label{sec:simplify}

Post-generation optimisation tweaks. i.e. \ignore|a && True => a|. Could perhaps use HLint in a future version.

\h{.hse}\begin{code}
simplify :: Biplate alpha Exp => alpha -> alpha
simplify = transformBi fExp
    where
        x ~= y = prettyPrint x == y

        fExp (App op (List xs))
            | op ~= "length" = Lit $ Int $ fromIntegral $ length xs
            | op ~= "head" = head xs
        fExp (InfixApp (Lit (Int i)) op (Lit (Int j)))
            | op ~= "-" = Lit $ Int $ i - j
            | op ~= ">" = Con $ UnQual $ Ident $ show $ i > j
        fExp (InfixApp x op y) | op ~= "`const`" = x
        fExp (App (App con x) y) | con ~= "const" = x
        fExp (Paren (Var x)) = Var x
        fExp (Paren (Lit x)) = Lit x
        fExp x = x
\end{code}

\subsection{DSL Usage}

What can we do with DSLs? The world is our Oyster, we can generate |Data| based reflective code, we can generate concrete instances, we can write out an instance generator.

Currently an instance is a fragment of compile time code, but using Haskell's reflection capabilities \cite{lammel:syb2}, instances could be derived at run-time, removing the inconvenience of a separate preprocessor.

\section{Results}
\label{sec:results}

\subsection{Limitations of Automatic Derivation}
\label{sec:failure}

The instance generation scheme given is not complete -- there exist instances whose generator cannot be determined. The Derive tool \cite{derive} is a program for generating instances for user defined data types. Of the 24 instances supported by the Derive tool, 15 are expressed by example, while 9 require manually written instance generators. There are several reasons some instances cannot be determined:

\begin{description}

\item[Non-inductive definitions:] For example, the |Binary| class serialises a value to disk. For each value, a tag is written to indicate the constructor. If a data type has only one constructor, the tag is omitted. These instances are not inductive -- the single constructor does not follow the same pattern.

\item[Type-based definitions:] For example, the |Monoid| class requires items of the same type to be processed using |mappend|, but items of a different type use |mempty|. Automatic derivation has no notion of type-specific behaviour.

\item [Record-based definitions:] Haskell provides records, which allow fields to be labelled. The |Show| class outputs the field name if present, but the examples have no notion of label-specific behaviour. By extending |Sample|, record definitions could be determined, but this change would increase the complexity of all other example instances.

\end{description}

\subsection{Generation of Standard Classes}
\label{sec:automatic_success}

Many instance generators can be expressed by example -- including some from the standard Haskell libraries (|Enum|, |Ord|, |Bounded|) and publicly distributed libraries (|Serial|, |Arbitrary|). The |Data| class was introduced in Scrap Your Boilerplate \cite{lammel:syb}, and allows Haskell programmers to write concise queries and transformations. The fundamental operation is |gfoldl|, which involves a fold over each value, and the application of an argument to join the fields. An example instance can be given as:

\begin{code}
instance Data alpha => Data (Sample alpha) where
    gfoldl k r (First            ) = r First
    gfoldl k r (Second  x_1 x_2  ) = r Second  `k` x_1 `k` x_2
    gfoldl k r (Third   x_1      ) = r Third   `k` x_1
\end{code}

\noindent The generator function is inferred as:

\ignore\begin{code}
instance Data \? <| dataname |> where
    <| MAP ctors (
        gfoldl k r
            (<| ctorname |> \? <| MAP [1..ctorarity] (x <| # |> ) |> ) =
            <| FOLDR k (r \? <| ctorname |>)
                <| MAP [1 .. ctorarity] (x <| # |> ) |>
            |>
    ) |>
\end{code}

\subsection{Tricks for Increasing Power}

Take a look at Binary, which writes out tags in clever ways.

\subsection{Timing Properties}

Inference time to write the derivations for everything to a file is under a tenth of a second. To write the data to the screen takes 3 tenths of a second. We conclude that guesses aren't too slow!

\subsection{Extensions}
\label{sec:extensions}

How would we increase it to get more power.

Record names could be added. The difficulty here is that record names can be shared between constructors, in different orders, some constructors may not have record names etc. For a system such as F\#, where only one constructor is allowed and all fields must be named, this may be more feasible.

Another property is types. The problem here is that types are two numerous, and while extensions could provide one or two -- for example |Functor|, they won't be able to do a huge number.

\section{Related Work}
\label{sec:related}

The purpose of this work is to find a pattern, and generalise that pattern to other situations. Genetic algorithms \cite{genetic_algorithms} are often used to automatically find a pattern in a data set. Genetic algorithms work by evolving a hypothesis (a gene sequence) and testing on a sample problem. They are well suited to search problems where the utility function is continuous -- close hypotheses have similar fitness. The main difference from this paper is that the hypothesis is random, whereas ours is strongly directed by the shape of the example.

The closest work we are aware of is that of the theorem proving community. Induction is a very common tactic for writing proofs, and well supported in systems such as HOL Light \cite{hol_light}. Typically the user must suggest the use of induction, which the system checks for validity. Automatic inference of an induction argument has been tried \cite{mintchev:reasoning}, but is rarely successful.

The concepts in this paper are applicable outside the domain of instances in Haskell. Any programming language operation that exhibits some degree of uniformity could be automated. To give one example: the object-orientated community have embraced design patterns \cite{design_patterns}, which involve many recurring patterns.

\section{Conclusions and Future Work}
\label{sec:conclusion}

We have presented a mechanism for automatically deriving instance generators for Haskell type classes. Our technique has been implemented in the Derive tool \cite{derive}, where 60\% of instance generators are specified by example. The ease of creating new instances has enabled several users to contribute instance generators to the Derive tool. We see several lines of future work:

\begin{itemize}
\item Using automatic instance generation allows the underlying tool to change the API for specifying instances, without requiring human intervention to modify the generators -- they can simply be regenerated. This freedom allows instances to be expressed in new ways.
\item The provided data type (Figure \ref{fig:sample}) allows many instances to be inferred -- but more would be desirable. One approach to specifying more instances would be to augment the existing data type with additional features, such as record names (see \S\ref{sec:failure}). An alternative approach would be to introduce new data types with features specifically targeted for certain types of definition. Care would have to be taken to ensure that these extensions do not substantially increase the complexity of writing examples.
\item We could make everything more type safe using GADT's.
\end{itemize}

Computers are ideally suited to applying repetitive patterns, but specifying these patterns can be complex and error prone. By specifying the result, instead of the pattern, a user can focus on what they want, rather than the mechanism by which this is realized.

\subsection*{Acknowledgements}

Thanks to Stefan O'Rear help with the first version of the \derive{} tool. Thanks to Niklas Broberg for the excellent haskell-src-exts librarys.


\bibliographystyle{plainnat}
\bibliography

\end{document}
