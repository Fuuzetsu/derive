\documentclass[preprint]{sigplanconf}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage{multirow}
\usepackage{setspace}
\usepackage{balance}

\include{paper}

%include paper.fmt

\newcommand{\derive}{\textsc{Derive}}

\hsdef{\begin{comment}
f
\end{comment}}
\begin{comment}
\begin{code}
\end{code}
\end{comment}

\begin{document}

\conferenceinfo{3rd workshop on Approaches and Applications of Inductive Programming}{date, City.} %
\copyrightyear{2009} %
\copyrightdata{[to be supplied]}

\titlebanner{\today{} - \currenttime{}}        % These are ignored unless
\preprintfooter{}   % 'preprint' option specified.

\title{Deriving a DSL from one example}
% \subtitle{}

\authorinfo{Neil Mitchell}
           {Standard Chartered, UK}
           {\verb"ndmitchell@gmail.com"}

\maketitle

\begin{abstract}
This paper describes how to infer a function |alpha -> beta|, given a single example pair for a particular element in |alpha|. Throughout we use the concrete example of getting type-class definitions in Haskell, where |alpha| is the set of Haskell data types and |beta| is the set of Haskell abstract syntax trees. We have produced a tool which can infer such instances, and which has seen practical use in the {\derive} tool, providing over 60\% of the type classes.
\end{abstract}

\category{D.3}{Software}{Programming Languages}

\terms
todo

\keywords
Haskell, todo

\section{Introduction}

Haskell \cite{haskell} is a modern functional programming language. In Haskell a generic function can be defined using a type class \cite{wadler:type_classes} (using the |class| keyword), and implementations can be provided for specific types (using the |instance| keyword). Generic equality is defined by the |Eq| class:

\begin{code}
class Eq alpha where
    (==) :: alpha -> alpha -> Bool
\end{code}

The |Eq| class has an operator, |(==)|. All types that are instances of the class |Eq| have the |(==)| operator available. We can define a Haskell data type, along with an instance for |Eq|, as follows:

\begin{code}
data WritingImplement  =  Pencil       -- a pencil
                       |  Pen Colour   -- a pen, plus its colour

instance Eq WritingImplement where
    (Pencil     )  == (Pencil     )  = True
    (Pen     x  )  == (Pen     y  )  = x == y
    _              == _              = False
\end{code}

The data type we introduce is |WritingImplement|. A |WritingImplement| is either a pencil, or a pen with a colour. |Pencil| and |Pen| are referred to as data constructors. The first line of the |Eq| instance says that any two |Pencil| values are equal. The second line says that for two |Pen| values to be equal, their colour fields must be equal. The final line says that any remaining pairs of values are not equal. Any instance of |Eq| follows naturally from the data structure: for two values to be equal they must have the same constructor, and all their fields must be equal.

Writing an |Eq| instance for one data type is simple. However, as the complexity and number of data types increases, so does the effort required. The standard solution is to express the \textit{relationship} between any data type and the instance that corresponds to it, which we call an \textit{instance generator}. In standard tools such as DrIFT \cite{drift}, the author of an instance generator must be familiar with both the representation of a data type, and various code-generation functions. The result is that specifying an instance generator is not as straightforward as one might hope.

\begin{figure}
\begin{code}
data DataName  =  First
               |  Second  Any
               |  Third   Any  Any
               |  Fourth  Any  Any
\end{code}
\caption{The |DataName| data type.}
\label{fig:dataname}
\end{figure}

Using the techniques described in this paper, instance generators can often be automatically inferred from a single example instance. To define \textit{all} |Eq| instances, an example must be given on the |DataName| type, provided by a library (see Figure \ref{fig:dataname}):

\begin{code}
instance Eq DataName where
    (First          )  == (First          )  = True
    (Second  x1     )  == (Second  y1     )  = x1 == y1 && True
    (Third   x1 x2  )  == (Third   y1 y2  )  = x1 == y1 && x2 == y2 && True
    (Fourth  x1 x2  )  == (Fourth  y1 y2  )  = x1 == y1 && x2 == y2 && True
    _                  == _                  = False
\end{code}

The |DataName| instance follows the same pattern as for |WritingImplement|, but with the addition of |&& True|, whose purpose is explained in \S\ref{sec:fold}.

This paper contributes a method for inferring a relationship between a value and a piece of program code, without resorting to unguided search. In our experience, over 60\% of Haskell class instances can be determined using this technique.

\subsection{Road Map}

We first formulate the problem abstractly (simple), then given concrete instantiations of each section.

\section{Abstractly}

Given an unknown function |alpha -> beta|, and a single example of the result for some given value in |alpha|, can we infer the function? What restrictions need to be imposed to infer the function reliably and quickly?

\begin{code}
data Input
data Output
data DSL

input :: Input -- a canonical input example
output :: Output -- given input

apply :: Input -> DSL -> Output
guess :: Output -> [DSL]

-- equivalence of DSL terms
d_1 ~== d_2 = forall i `elem` Input `o` apply i d_1 == apply i d_2

-- guess is correct
forall o `elem` guess output `o` apply input o == output

-- predictability
forall d_1, d_2 `elem` DSL `o` apply input d_1 == apply input d_2 => d_1 ~== d_2
\end{code}

\subsection{Correctness}

Correctness of guess can be assured with:

\begin{code}
guess x = [y | y <- guess' x, apply input y == output]
\end{code}

Now |guess'| can be written without regard to correctness.

\subsection{Predictability}

The predictability lemma requires that if a DSL successfully guesses the input/output pair, it must be equivalent to all other possible DSL. Note that the predictability lemma does not mention |guess|, although it may require a specially chosen |input| value.

By combining the predictability lemma with the correctness lemma, we can guarantee that if |guess| returns any results, any result is equally good to any other. This frees |guess| from any burden. Combined with defining |guess| in terms of |guess'| allows us to write any terminating expression for |guess| and still get correct behavior.

\section{Concretely}

\subsection{Output}

Our output language is the language of Haskell declarations. Because of the tool we're writing, we don't have a choice about the output domain. Internally we use haskell-src-exts, but that has a big tree. To simplify things we use a universal data type, we translate to and from hse \ref{todo}.

\begin{code}
data Output = OString String
            | OInt Int
            | OList [Output]
            | OApp String [Output]
\end{code}

\subsection{Input}

We have more freedom over input. We choose which information to present in a data type, for example we can choose to make the derivation depend on the module name, or not. We choose not too, however this does eliminate some derivations \ref{typeable}. In \ref{extensions} we describe how you could beef up the power.

Our |Input| language is that of algebraically constructed Haskell data types:

\begin{code}
data Input = Input {dataName :: String, dataVars :: Int, dataCtors :: [Ctor]}
data Ctor = Ctor {ctorName :: String, ctorIndex :: Int, ctorArity :: Int}
\end{code}

Note the details we choose to represent and the details we abstract away. For example, we allow derivations to depend on the arity or index of a constructor, but not the types of the constructors arguments.

\subsection{DSL}

The DSL we have most freedom over.

\subsubsection{Constants}

One useful thing is to represent is constants, so we can lift the |Output| type in to |DSL|.

\begin{code}
data DSL = DString String
         | DInt Int
         | DList [DSL]
         | DApp String [DSL]
\end{code}

\subsubsection{Operations}

\begin{code}
data DSL = ...
         | Append DSL DSL
         | ShowInt DSL
         | DApp String [DSL]
\end{code}

These operations are fairly general.

\subsubsection{Constructors}

We also want to talk about constructors:

\begin{code}
data DSL = ...
         | CtorIndex
         | CtorArity
         | CtorName
         | MapCtor DSL
\end{code}

\subsubsection{Fields}

\begin{code}
data DSL = 


\subsubsection{Custom items}

\begin{code}
data DSL = ...
         | Instance 
\end{code}



\subsection{Restrictions for predictability}

You can only refer to the arity of something if you also refer to it's constructor name. You can't have a constructor name as a constant. Consider:

\begin{code}
instance Arities Ctors where
    arities _ = [0,1,2,2]
\end{code}

However, it's easy to write:

\begin{code}
instance Arities Ctors where
    arities _ = map fst [(0,"CZero"),(1,"COne"),(2,"CTwo"),(2,"CThree")]
\end{code}

\section{Implementing |guess|}

\section{Implementation Details}

SYB stuff goes in here. Haskell-src-exts.

Post-generation optimisation tweaks. i.e. |a && True => a|. Could perhaps use HLint in a future version.

\section{Results}

\subsection{Limitations of Automatic Derivation}
\label{sec:automatic_failure}

The instance generation scheme given is not complete -- there exist instances whose generator cannot be determined. The Derive tool \cite{derive} is a program for generating instances for user defined data types. Of the 24 instances supported by the Derive tool, 15 are expressed by example, while 9 require manually written instance generators. There are several reasons some instances cannot be determined:

\begin{description}

\item[Non-inductive definitions:] For example, the |Binary| class serialises a value to disk. For each value, a tag is written to indicate the constructor. If a data type has only one constructor, the tag is omitted. These instances are not inductive -- the single constructor does not follow the same pattern.

\item[Type-based definitions:] For example, the |Monoid| class requires items of the same type to be processed using |mappend|, but items of a different type use |mempty|. Automatic derivation has no notion of type-specific behaviour.

\item [Record-based definitions:] Haskell provides records, which allow fields to be labelled. The |Show| class outputs the field name if present, but the examples have no notion of label-specific behaviour. By extending |DataName|, record definitions could be determined, but this change would increase the complexity of all other example instances.

\end{description}

\subsection{Generation of Standard Classes}
\label{sec:automatic_success}

Many instance generators can be expressed by example -- including some from the standard Haskell libraries (|Enum|, |Ord|, |Bounded|) and publicly distributed libraries (|Serial|, |Arbitrary|). The |Data| class was introduced in Scrap Your Boilerplate \cite{lammel:syb}, and allows Haskell programmers to write concise queries and transformations. The fundamental operation is |gfoldl|, which involves a fold over each value, and the application of an argument to join the fields. An example instance can be given as:

\begin{code}
instance Data DataName where
    gfoldl k r (First          ) = r First
    gfoldl k r (Second  x1     ) = r Second  `k` x1
    gfoldl k r (Third   x1 x2  ) = r Third   `k` x1 `k` x2
    gfoldl k r (Fourth  x1 x2  ) = r Fourth  `k` x1 `k` x2
\end{code}

\noindent The generator function is inferred as:

\begin{code}
instance Data \? <| dataname |> where
    <| MAP ctors (
        gfoldl k r
            (<| ctorname |> \? <| MAP [1..ctorarity] (x <| # |> ) |> ) =
            <| FOLDR k (r \? <| ctorname |>)
                <| MAP [1 .. ctorarity] (x <| # |> ) |>
            |>
    ) |>
\end{code}

\section{Extensions}

How would we increase it to get more power.

\section{Related Work}
\label{sec:related}

The purpose of this work is to find a pattern, and generalise that pattern to other situations. Genetic algorithms \cite{genetic_algorithms} are often used to automatically find a pattern in a data set. Genetic algorithms work by evolving a hypothesis (a gene sequence) and testing on a sample problem. They are well suited to search problems where the utility function is continuous -- close hypotheses have similar fitness. The main difference from this paper is that the hypothesis is random, whereas ours is strongly directed by the shape of the example.

The area of optical character recognition \cite{ocr} has some similar characteristics -- a page is analysed to look for common patterns (pictures or text passages), which can be processed further. This is related to the process of using the fold pattern (\S\ref{sec:fold}), where a repeating pattern is detected. The difference is that character recognition works on image data, which does not have the same precision as program code.

The closest work we are aware of is that of the theorem proving community. Induction is a very common tactic for writing proofs, and well supported in systems such as HOL Light \cite{hol_light}. Typically the user must suggest the use of induction, which the system checks for validity. Automatic inference of an induction argument has been tried \cite{mintchev:reasoning}, but is rarely successful.

The concepts in this paper are applicable outside the domain of instances in Haskell. Any programming language operation that exhibits some degree of uniformity could be automated. To give one example: the object-orientated community have embraced design patterns \cite{design_patterns}, which involve many recurring patterns.

\section{Conclusions and Future Work}
\label{sec:conclusion}

We have presented a mechanism for automatically deriving instance generators for Haskell type classes. Our technique has been implemented in the Derive tool \cite{derive}, where 60\% of instance generators are specified by example. The ease of creating new instances has enabled several users to contribute instance generators to the Derive tool. We see several lines of future work:

\begin{itemize}
\item Using automatic instance generation allows the underlying tool to change the API for specifying instances, without requiring human intervention to modify the generators -- they can simply be regenerated. This freedom allows instances to be expressed in new ways. Currently an instance is a fragment of compile time code, but using Haskell's reflection capabilities \cite{lammel:syb2}, instances could be derived at run-time, removing the inconvenience of a separate preprocessor.
\item The provided data type (Figure \ref{fig:dataname}) allows many instances to be inferred -- but more would be desirable. One approach to specifying more instances would be to augment the existing data type with additional features, such as record names (see \S\ref{sec:automatic_failure}). An alternative approach would be to introduce new data types with features specifically targeted for certain types of definition. Care would have to be taken to ensure that these extensions do not substantially increase the complexity of writing examples.
\item We could make everything more type safe using GADT's.
\end{itemize}

Computers are ideally suited to applying repetitive patterns, but specifying these patterns can be complex and error prone. By specifying the result, instead of the pattern, a user can focus on what they want, rather than the mechanism by which this is realized.





\balance

\bibliographystyle{plainnat}
\bibliography

\end{document}
