% Note:
% I'm thinking of submitting this to the York Doctoral Symposium
% http://www.cs.york.ac.uk/yds/
%
% Perhaps after it could be revamped as a The Monad.Reader article
% with more on the Derive side of things?

\documentclass{llncs}

\usepackage{url}
\usepackage{comment}

%include polycode.fmt
%include derive.fmt

\begin{document}

\title{Deriving Generic Functions by Example}
\author{Neil Mitchell}

\institute{University of York, UK\\
\url{http://www.cs.york.ac.uk/~ndm/}}

\maketitle

\begin{abstract}
A function is said to be \textit{generic} if it operates over values of \textit{any} data type. For example, a generic equality function can test pairs of booleans, integers, lists, trees etc. In most languages programmers must define generic functions multiple times, specialised for each data type. Alternatively, a tool could be used to specify the relationship between the data type and the implementation, but this relationship may be complex.

This paper describes a solution: given a single example of the generic function on one data type, we can infer the relationship between a data type and the implementation. We have used our method in the Derive tool, allowing the implementation of 60\% of generic functions to be inferred.
\end{abstract}

\section{Introduction}

Haskell \cite{haskell} is a modern functional programming language. In Haskell a generic function can be defined using a type class \cite{wadler:type_classes} (the |class| keyword), and implementations can be provided for specific types (the |instance| keyword). Generic equality is defined by the |Eq| class:

\begin{code}
class Eq alpha where
    (==) :: alpha -> alpha -> Bool
\end{code}

The |Eq| class has a member |(==)|. All types which provide an |Eq| instance have the |(==)| operator available. We can define a Haskell data type, along with an instance for |Eq|, as follows:

\begin{code}
data WritingImplement  =  Pencil       -- a pencil
                       |  Pen Colour   -- a pen, plus its colour

instance Eq WritingImplement where
    (Pencil     )  == (Pencil     )  = True
    (Pen     x  )  == (Pen     y  )  = x == y
    _              == _              = False
\end{code}

The data type we introduce is |WritingImplement|. A value of this type is either the constructor |Pencil|, or the constructor |Pen| with a colour field. We can define an |Eq| instance as above. The first line says that any two |Pencil| values are equal. The second line says that for two |Pen| values to be equal, their fields must be equal. The final line says that any remaining pairs of values are not equal. Any instance of |Eq| follows naturally from the data structure: for two values to be equal they must have the same constructor, and the their fields must be equal.

Writing an |Eq| instance for one data type is not an undue burden. However, as the complexity and number of data types increases, so does the effort required. The solution is to express the relationship between a data type and its instance once, which we call an \textit{instance generator}. In standard tools such as DrIFT \cite{drift}, the author of an instance generator must be familiar with both the representation of a data type, and various code-generation functions. The result is that specifying an instance generator is a complex process.

\begin{figure}[tbp]
\begin{code}
data DataName  =  CtorZero
               |  CtorOne    Any
               |  CtorTwo    Any  Any
               |  CtorThree  Any  Any
\end{code}
\caption{The |DataName| data type.}
\label{fig:dataname}
\end{figure}

Using the techniques described in this paper, instance generators can be automatically inferred from a single example instance. To define \textit{all} |Eq| instances, an example must be given on the provided |DataName| type (see Figure \ref{fig:dataname}):

\begin{code}
instance Eq DataName where
    (CtorZero          )  == (CtorZero          )  = True
    (CtorOne    x1     )  == (CtorOne    y1     )  = x1 == y1 && True
    (CtorTwo    x1 x2  )  == (CtorTwo    y1 y2  )  = x1 == y1 && x2 == y2 && True
    (CtorThree  x1 x2  )  == (CtorThree  y1 y2  )  = x1 == y1 && x2 == y2 && True
    _                     == _                     = False
\end{code}

This paper contributes a practical method for inferring a relationship between two pieces of program code, without resorting to search. In particular, the notion that the relationship is \textit{parameterised} is central.

\subsection{Roadmap}

This paper first describes how to derive instance generators automatically in \S\ref{sec:automatic_instances}. \S\ref{sec:automatic_failure} discusses which generic functions are applicable for this scheme, and \S\ref{sec:automatic_success} gives more complex examples. \S\ref{sec:related} presents related work, before \S\ref{sec:conclusion} concludes.


\begin{comment}
\section{Manual Instance Generators}
\label{sec:manual_instances}

There are currently three mechanisms for specifying and invoking instance generators -- all offering different levels of compiler integration and extensibility.

\subsection{Built in deriving}

The simplest instance generator is provided by Haskell itself, with the |deriving| keyword. The |Eq| instance given above could have been automatically derived by the compiler, simply by adding |deriving Eq| at the end of the data type declaration.

Unfortunately this scheme has two primary disadvantages. Firstly, the deriving keyword \textit{must} appear after the data type declaration -- if the data type is declared in a library, a new instance may not be derived. Secondly, only six inbuilt type classes are supported -- there is no way to add more.

\subsection{The DrIFT tool}

The DrIFT tool \cite{drift} is a Haskell preprocessor -- which examines a source file for special annotations, and appends the code for requested instances. DrIFT has support for 29 instance generators, but adding more requires making modifications to DrIFT itself.

To write an instance generator for DrIFT requires the implementation of a function, which takes a representation of a data type, and generates Haskell code. The code must be generated using special functions to ensure it has the correct layout. The author of an instance generator must be familiar with both the representation of the data structure, and with the code-generation functions.

\subsection{The Derive tool}

The Derive tool \cite{derive} is a competitor to DrIFT, designed to alleviate some of the disadvantages. The first advantage is that instance generators can added easily, without modifying the Derive tool. Secondly, by using the Template Haskell \cite{template_haskell} extension, no preprocessing phase is required. In order to integrate with Template Haskell, an instance generator takes a representation of a data type, and generates a Haskell syntax tree.

Writing an instance generator requires knowledge of the representation of both the data type, and the Haskell syntax tree. Unfortunately, the Haskell syntax tree is represented by a large data type, which takes time to learn. After writing an instance generator, the user must check that the generator matches their intention, by testing on a suitable range of data types. Both of these factors increase the time required to write an instance generator.

We have integrated automatic derivation of an instance generator, following the scheme in this paper, into the Derive tool. In order to specify a new instance generator, the user can \textit{either} specify a derivation function, \textit{or} have one automatically generated from an example.
\end{comment}

\section{The Method}
\label{sec:automatic_instances}

The central idea of automatic inference of instance generators is that an instance generator is merely a function from data types to code fragments. By applying a specific data type to the function, the appropriate code will be generated. In order to infer generation functions in a practical way, it is necessary infer a function on each fragment of code separately, then combine them.

\subsection{Parameter types}

The instance generator is parameterised by a data type. Smaller fragments of the code may be parameterised by constructors, numbers, or have no parameter. We outline the types of parameter, along with examples of the fragments which are assigned that parameter.

\begin{description}
\item[A constant:] A fragment of the implementation can be a constant, meaning that in all cases it will generate the same value. In the original example things such as |True|, |instance|, |(==)|, |(&&)| etc. are constant. Anything which does not have an alternative parameterisable function is assumed to be constant.

\item[A number:] The fragment |x1| is parameterised by the number |1|, with the hypothesis that the result is simply the number. We use the notation |1 ->> x <|| i ||> | to denote the function, where |i| is the parameterised number, and |1| is the parameter. Any detected number is either a parameterised value, or a constant.

\item[A constructor:] The fragment |CtorTwo| is parameterised by the constructor |CtorTwo|, being the name of the constructor. We use the notation |CtorTwo ->> <|| ctorname ||> | to denote this function.

\item[A data type:] In the first example the whole code is parameterised by the data type. One particular place parameterised directly on the data type is |Eq DataName|, which becomes |DataName ->> Eq <|| dataname ||>|. If the name of the data type changes (to say |WritingImplement|), then the function would generate |Eq WritingImplement|.
\end{description}

\subsection{The Map Pattern}
\label{sec:induction}

The examples shown previously map values to constant-sized code fragments. But consider the pattern |CtorTwo x1 x2|, we require |n| variables, where |n| is the arity of the constructor. To solve this problem, we can construct a generalised map from a list of fragments. This construction requires two conditions: (1) any item has a function which is is correct on all fragments; (2) their parameter values are sequential.

\begin{code}
[1 ->> x <| i |>, 2 ->> x <| i |>]
\end{code}

Picking either function, when applying it to the other parameter, we obtain the correct value. The parameters are clearly sequential. We can rewrite this fragment using a |MAP| as:

\begin{code}
2 ->> <| MAP [1..i] (x <| i |> ) |>
\end{code}

|MAP| takes two arguments, a range of items to use as the parameter, and an expression to apply to each. Within the second argument, |i| is bound to the number currently being operated over. The function is now parameterised by the highest number in the sequence. We can also have a |MAP| which operates over constructors, in which case the resultant |MAP| is parameterised by the entire data type.

To give two examples of sequences which cannot be generalised to a |MAP|:

\begin{code}
[1 ->> x <| i |>, 3 ->> x <| i |>]
[1 ->> x <| i |>, 2 ->> y <| i |>]
\end{code}

In the first the parameters are not sequential. In the second, no function applies to both fragments.

The |MAP| pattern provides the key power to generalising an example from one specific type, to any type. In order to increase the chance of finding a suitable generalisation, we allow each fragment of code to be represented by a list of possible parameterised functions \cite{wadler:list_successes}.


\subsection{The Fold Pattern}
\label{sec:fold}

One common pattern in programming is the \textit{fold} \cite{hutton:fold}. Consider the |Eq| example from before. If we move to using prefix notation for |(&&)| and explicit bracketing we obtain:

\begin{code}
(CtorTwo x1 x2) == (CtorTwo y1 y2) = (&&) (x1 == y1) ((&&) (x2 == y2) True)
 -- or, expressed as a fold
(CtorTwo x1 x2) == (CtorTwo y1 y2) = foldr (&&) True [x1 == y1, x2 == y2]
\end{code}

This structure is not a list, and would not be found as a |MAP|. However, we can convert this function to a fold, recovering the list structure. A fold takes a list, and replaces each cons in the list by a function (i.e. |(&&)|) and the nil by a value (i.e. |True|). By automatically converting the code to use fold, a |MAP| is recovered. Using a |FOLDR| rule, the result is:

\begin{code}
2 ->> <| FOLDR (&&) True \? <| MAP [1..i] (x <| i |> == y <| i |>) |> |>
\end{code}

The |FOLDR| rule is simply a |foldr| function, but applied at generation time. The fold encoding explains the redundant |&& True| at the end -- in order for the base case (|True|) to share the same fold definition as above, we require a redundant conjunct. In the code generated for instances |&& True| is removed, using algebraic simplification.


\subsection{Eliminating Number Parameters}

Initially functions may be parameterised by the whole data type, constructors and numbers. The |MAP| rule converts functions parameterised on constructors to the whole data type, but leaves numbers parameterised by numbers. There is a final rule which is used to eliminate numbers, namely promotion into another parameter type. The idea is that a number is replaced with a constructor with a relationship to that number, taking the example of |x1 x2| from earlier, we can write any of:

\begin{code}
2          ->> <| MAP [1..i          ] (x <| i |> ) |>
CtorTwo    ->> <| MAP [1..ctorarity  ] (x <| i |> ) |>
CtorTwo    ->> <| MAP [1..ctorindex  ] (x <| i |> ) |>
CtorThree  ->> <| MAP [1..ctorarity  ] (x <| i |> ) |>
\end{code}

Instead of parameterising by a number, we can parameterise by |CtorTwo|, and use its arity. The number 2 can be constructed in many ways: it is both the arity, and zero-based index of |CtorTwo|, and also the arity of |CtorThree|.

\subsection{The Result}

After all this work, the resultant function for the |Eq| example is:

\begin{code}
instance Eq \? <| dataname |> where
    <| MAP ctors (
        (<| ctorname |> \? <| MAP [1..ctorarity] (x <| i |> ) ) ==
        (<| ctorname |> \? <| MAP [1..ctorarity] (x <| i |> ) ) =
        <| FOLDR (&&) True \? <| MAP [1..ctorarity] (x <| i |> == y <| i |>) |> |>
    ) |>
    _ == _ = False
\end{code}

Applying this function to |WritingImplement| will give us the instance we manually specified. Writing this function directly would pose a number of difficulties:

\begin{enumerate}
\item There is no language in which to write such a function. A library could be written facilitating this (and indeed, this has been done \cite{drift}), but it is merely an encoding of this form.
\item Details such as the associativity of |(&&)| can be omitted from an example, but are required when expressing a |FOLDR|.
\item There is no guarantee that this generator produces type-safe instances.
\item The generated code would have to be tested, probably on several data types, to check it has the required behaviour.
\item The complexity, compared to a single example, is much higher.
\end{enumerate}


\begin{comment}
\section{Automatic Instance Generator Derivation}
\label{sec:automatic_instances}

This section describes how to derive an instance generator, given an example instance. There are four key aspects: \S\ref{sec:generation} generating and testing a hypothesis; \S\ref{sec:environment} the environment in which a hypothesis exists; \S\ref{sec:induction} induction on lists; \S\ref{sec:fold} induction on folds.

\subsection{Hypothesis Generation and Testing}
\label{sec:generation}

The idea behind hypothesis generation is that given a value, a hypothesis determines both an environment, and a mapping from an environment to the original value. An environment captures the aspects that are particular to a data type, and would change given a different data type. This technique of introducing an environment allows the hypothesis to be parameterised by the data type.

In order to guess a data type |tau|, we can define:

\begin{code}
data Hypothesis tau = Hypothesis Env (Env -> tau) String

guess :: tau -> [Hypothesis tau]
\end{code}

The |guess| function takes a value of type |tau|, and returns a list of hypotheses. Each hypothesis is an environment in which the value was found, a function to construct the value given an environment, and a string representation of the instance generator. Applying the returned environment to the value generator must return the original value.


\subsection{The Enclosing Environment}
\label{sec:environment}

An environment represents the parameterisable aspects of a hypothesis. The |Env| data type is defined as:

\begin{code}
data Env = Empty | Ctor Int | Field Int
\end{code}

There are three different types of environment. The empty environment (|Empty|) provides a value which is constant. The constructor environment (|Ctor|) uses information from a particular constructor -- for example the constructor name, the arity or the 0-based index. The field environment (|Field|) provides the index of a field within a constructor.

For each terminal value in the syntax tree, an environment is produced, which generates the value. If the name |CtorOne| was encountered this would be assigned the environment |Ctor 1| -- being the constructor name for the appropriate constructor. If the name |True| was encountered the environment would be |Empty| -- no constructors or fields relate to the value |True|. If a variable ends in a number, i.e. |x1|, then the number is separately assigned an environment.

\begin{figure}[t]
\begin{code}
guessNum :: Int -> [Env]
guessNum i  =        [Field i  | i `elem` [1..2]  ]  -- a field
            `union`  [Empty    | i `elem` [3..4]  ]  -- the number of constructors
            `union`  [Ctor i   | i `elem` [0..3]  ]  -- the constructor index
            `union`  [Ctor i   | i `elem` [0..2]  ]  -- the constructor arity
            `union`  [Ctor 3   | i == 2           ]  -- the constructor arity
\end{code}
\caption{The function |guessNum|, which guesses an environment from a number.}
\label{fig:guessnum}
\end{figure}

The value with most possible environments is a number. Take for instance the number 2 -- within |DataName| (Figure \ref{fig:dataname}) this could correspond to the field in position 2, the arity of |CtorTwo| or |CtorTwo'|, the index of |CtorTwo|, or simply a constant. The code to compute the possible environments from a number is given in Figure \ref{fig:guessnum}. The list of environments allows many possible hypotheses to be generated for a single value.


\subsection{List Induction on Environments}

For most types, |guess| is defined as guessing all the sub-components, then combining these guesses back together. Lists are treated differently -- by finding an inductive relationship over the list, the hypothesis can be made more generally applicable. Each element of the list is first guessed, then, if possible, the generated environments are merged. A few examples of how environments may be merged:

\begin{code}
[Field 0, Field 1]                => Ctor 2 {-" \;\; or \;\; "-} Ctor 3
[Ctor 0, Ctor 1, Ctor 2, Ctor 3]  => None
\end{code}

If the environments are of the same type, and are consecutive, they can be placed in an enclosing environment. A list of consecutive fields can be generalised into a constructor which contains those fields. A list of all constructors can be combined into the empty environment, since operating over all constructors can be done independently of the constructors present.

The generalisation of an environment is not correct if the individual hypotheses are incompatible. Before returning a new environment, it is necessary to \textit{test} all the values against one of the generation functions. If a suitable generator is found, it is applied to all elements in the list to form a new generator.

List induction is key, without it instances would not generalise from a specific data type to all data types.

\subsection{Fold Induction on Environments}

One common pattern in instance definitions is the \textit{fold} \cite{hutton:fold}. Consider the |Eq| example from before. If we move to using prefix notation for |(&&)| and explicit bracketing we obtain:

\begin{code}
(CtorTwo x1 x2) == (CtorTwo y1 y2) = (&&) (x1 == y1) ((&&) (x2 == y2) True)
 -- or, expressed as a fold
(CtorTwo x1 x2) == (CtorTwo y1 y2) = foldr (&&) True [x1 == y1, x2 == y2]
\end{code}

This structure is not a list, and would not be found by list induction. However, we can convert this function to a fold, recovering the list structure. A fold takes a list, and replaces each cons in the list by a function (i.e. |(&&)|) and the nil by a value (i.e. |True|). By automatically converting the code to use fold, the list induction is able to work.

The fold encoding explains the redundant |&& True| at the end -- in order for the base case (|True|) to share the same fold definition as above, we require a redundant conjunct. In the code generated for instances |&& True| is removed, using algebraic simplification.
\end{comment}

\section{Limitations of Automatic Derivation}
\label{sec:automatic_failure}

Having defined a mechanism for inductive instances, it is useful to determine which instances can be automatically derived, and which must be written manually. Of the 24 instances provided by the Derive tool \cite{derive}, 15 are expressed by example, and 9 require hand-coding. There are several reasons for the automatic method to be inappropriate:

\begin{description}

\item[Non-inductive definitions:] The |Binary| class serialises a value to disk. For each value a tag is written to indicate the constructor. If a data type only has one constructor the tag is omitted. These instances are not inductive -- the change from one constructor to two does not follow the same pattern.

\item[Typebased definitions:] The |Monoid| class requires items of the same type to be processed using |mappend|, but items of a different type use |mempty|. Automatic derivation has no notion of type-specific behaviour.

\item [Record-based definitions:] Haskell provides records, which allow fields to be labelled. The |Show| class outputs the field name if present, but the examples have no notion of label-specific behaviour.

\end{description}

Even with these restrictions, the majority of classes can be expressed in a manner which allows the automatic derivation to succeed.

\section{Successes of Generation}
\label{sec:automatic_success}

In this section we present a small number of example instances, from pre-existing libraries, which are derived by example.

\subsection{The Data class}

The |Data| class was introduced in Scrap Your Boilerplate \cite{lammel:syb}, and allows Haskell programmers to write concise queries and transformations. The fundamental operation is |gfoldl|, which involves a fold over each value, and the application of an argument to join the fields.

\begin{code}
instance (Data alpha, Typeable alpha) => Data (DataName alpha) where
    gfoldl k r (CtorZero          ) = r CtorZero
    gfoldl k r (CtorOne    x1     ) = r CtorOne    `k` x1
    gfoldl k r (CtorTwo    x1 x2  ) = r CtorTwo    `k` x1 `k` x2
    gfoldl k r (CtorThree  x1 x2  ) = r CtorThree  `k` x1 `k` x2
\end{code}

\subsection{The Serial class}

The |Serial| class is used by SmallCheck \cite{smallcheck} to automatically perform enumerative testing. The definition relies on the arities of each constructor, and does not induct over the the components of a constructor.

\begin{code}
instance Serial alpha => Serial (DataName alpha) where
    series = cons0 CtorZero \/ cons1 CtorOne  \/ cons2 CtorTwo  \/ cons2 CtorThree
\end{code}

\section{Related Work}
\label{sec:related}

The purpose of this work is to find a pattern, and generalise the pattern to other situations. Genetic algorithms \cite{genetic_algorithms} are often used to automatically find a pattern in a data set. Genetic algorithms work by evolving a hypothesis (a gene sequence) and testing on a sample problem. They are well suited to search problems where the utility function is continuous -- close hypothesises have similar fitness. The main difference from this paper is that the hypothesis is random, whereas ours is strongly directed by the shape of the example.

The area of optical character recognition \cite{ocr} has some similar characteristics -- a page is analysed to look for common patterns (pictures or text passages), which can be analysed further. This is related to the process of detecting fold (\S\ref{sec:fold}), where a repeating pattern is detected. The difference is that character recognition works on image data, which does not have the same precision as program code.

The closest work we are aware of is that in the theorem proving community. Induction is a very common tactic for writing proofs, and well supported. Using a system such as HOL Light \cite{hol_light} it is possible to instruct the prover to try the induction tactic. Typically the induction proof must be supplied initially, and is then checked for validity. Automatic inference of an induction argument has been tried \cite{mintchev:reasoning}, but is rarely successful.

The concepts in this paper are applicable outside the domain of instances in Haskell. Any programming language operation that exhibits some degree of uniformity could be automated. To take one example: the object-orientated community have embraced design patterns \cite{design_patterns}, which involve a many common recurring patterns.

\section{Conclusion and Future Work}
\label{sec:conclusion}

We have presented a mechanism for automatically deriving instances for Haskell programs. Using our scheme, even a novice programmer is able to define many classes, simply by supplying examples. To define a class does not require learning a new library, increasing the user base.

Now that the computer is able to infer the rules required for constructing a type, this information could be put to other uses. If the Derive API changed, the new instances would be regenerated with no effort. Using Haskell's reflection capabilities \cite{lammel:syb2}, instances could be derived at run-time, removing the inconvenience of separate preprocessors.

It may be possible by modifying the example data type (Figure \ref{fig:dataname}) to allow additional instances to be inferred. While we suspect that instances depending on record names can be inferred, we have yet to determine how to do so without complicating the data type for all instances.

Computers are ideally suited for applying repetitive patterns, but specifying those patterns can be tiresome. We hope that this work goes some way towards alleviating the specification burden. The Derive tool has been released, and makes extensive use automatic instance derivation. By lowering the barrier to defining instance generators, we have already benefited from several external contributions of new generic functions.

\paragraph{Acknowledgements}

Thanks to Matt Naylor for helpful suggestions on the presentation of this work. Thanks to Stefan O'Rear for work on the Derive tool.

\bibliographystyle{plain}
\bibliography{derive}


\end{document}
