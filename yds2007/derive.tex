% Note:
% I'm thinking of submitting this to the York Doctoral Symposium
% http://www.cs.york.ac.uk/yds/
%
% Perhaps after it could be revamped as a The Monad.Reader article
% with more on the Derive side of things?

\documentclass{llncs}

\usepackage{url}

%include polycode.fmt
%include derive.fmt

\begin{document}

\title{Deriving Inductive Instances by Example}
\author{Neil Mitchell}

\institute{University of York, UK\\
\url{http://www.cs.york.ac.uk/~ndm/}}

\maketitle

\begin{abstract}
For certain functions, the implementation is dependent on the structure of the data type upon which it operates. In some cases, it is possible to automatically infer the relationship between the data type and the code, merely by looking at a single example. This paper presents a mechanism for such an inference scheme.

In Haskell, a type-class defines an operation which is parameterised by the data type. This pattern is common, and often can be computed by automatic inference. We have implemented such as scheme in the Derive tool, allowing over 60\% of instances to be inferred.
\end{abstract}

\section{Introduction}

Haskell \cite{haskell} is a modern functional programming language. One of the novel features in Haskell is the ability to define one function which operates upon different types, but in a type specific manner -- known as type-classes \cite{wadler:type_classes}. One such type class is |Eq|, defined as:

\begin{code}
class Eq alpha where
    (==) :: alpha -> alpha -> Bool
\end{code}

The |Eq| class has a member |(==)|. All types which provide an |Eq| instance have the |(==)| operator available. We can define a Haskell data type, along with an instance for |Eq|, as follows:

\begin{code}
data Degree  =  MSc        -- someone doing an MSc
             |  PhD Int    -- PhD student, plus year of study

instance Eq Degree where
    (MSc    )  == (MSc    )  = True
    (PhD x  )  == (PhD y  )  = x == y
    _          == _          = False
\end{code}

The data type we introduce is |Degree|. A value of type |Degree| is either the constructor |MSc|, or the constructor |PhD| with an integer field. We can define an |Eq| instance as above. The first line says that any two |MSc| values are equal. The second line says that for two |PhD| values to be equal, their fields must be equal. The final line says that any remaining pairs of values are not equal.

\begin{figure}
\begin{code}
data DataName alpha = CtorZero | CtorOne alpha | CtorTwo alpha alpha | CtorTwo' alpha alpha
\end{code}
\caption{The |DataName| data type.}
\label{fig:dataname}
\end{figure}

The standard instance of |Eq| follows naturally from a data structure: for two values to be equal they must have the same constructor, and the their fields must be equal. This relationship can be expressed as a mapping from a data type, to a fragment of code -- which we call an \textit{instance generator}. Using the techniques described in this paper, instance generators can be automatically inferred from a single example instance. To define \textit{all} |Eq| instances, an example must be given on the provided |DataName| type (see Figure \ref{fig:dataname}):

\begin{code}
instance Eq alpha => Eq (DataName alpha) where
    (CtorZero         )  == (CtorZero         )  = True
    (CtorOne   x1     )  == (CtorOne   y1     )  = x1 == y1 && True
    (CtorTwo   x1 x2  )  == (CtorTwo   y1 y2  )  = x1 == y1 && x2 == y2 && True
    (CtorTwo'  x1 x2  )  == (CtorTwo'  y1 y2  )  = x1 == y1 && x2 == y2 && True
    _                    == _                    = False
\end{code}

The automatic instance generation takes this example, and makes several \textit{hypotheses} as to the mapping from data type to code. Each hypothesis is then \textit{tested} against the supplied example. After finding a valid hypothesis, a specific instance generator is created.

\subsection{Roadmap}

This paper first describes how manual instance generators must be written in \S\ref{sec:manual_instances}, including their disadvantages. In \S\ref{sec:automatic_instances} we look at how automatic instance generators are created. \S\ref{sec:automatic_failure} discusses which instances are applicable for this scheme, and \S\ref{sec:automatic_success} gives examples. \S\ref{sec:related} presents related work, before \S\ref{sec:conclusion} concludes.


\section{Manual Instance Generators}
\label{sec:manual_instances}

There are currently three mechanisms for specifying and invoking instance generators -- all offering different levels of compiler integration and extensibility.

\subsection{Built in deriving}

The simplest instance generator is provided by Haskell itself, with the |deriving| keyword. The |Eq| instance given above could have been automatically derived by the compiler, simply by adding |deriving Eq| at the end of the data type declaration.
 
Unfortunately this scheme has two primary disadvantages. Firstly, the deriving keyword \textit{must} appear after the data type declaration -- if the data type is declared in a library, a new instance may not be derived. Secondly, only six inbuilt type classes are supported -- there is no way to add more.

\subsection{The DrIFT tool}

The DrIFT tool \cite{drift} is a Haskell preprocessor -- which examines a source file for special annotations, and appends the code for requested instances. DrIFT has support for 29 instance generators, but adding more requires making modifications to DrIFT itself.

To write an instance generator for DrIFT requires the implementation of a function, which takes a representation of a data type, and generates Haskell code. The code must be generated using special functions to ensure it has the correct layout. The author of an instance generator must be familiar with both the representation of the data structure, and with the code-generation functions.

\subsection{The Derive tool}

The Derive tool \cite{derive} is a competitor to DrIFT, designed to alleviate some of the disadvantages. The first advantage is that instance generators can added easily, without modifying the Derive tool. Secondly, by using the Template Haskell \cite{template_haskell} extension, no preprocessing phase is required. In order to integrate with Template Haskell, an instance generator now takes a representation of a data type, and generates a Haskell syntax tree.

Writing an instance generator requires knowledge of the representation of both the data type, and the Haskell syntax tree. Unfortunately, the Haskell syntax tree is represented by a large data type, which takes time to learn. After writing an instance generator, the user must check that the generator matches their intention, by testing on a suitable range of data types. Both of these factors increase the time required to write an instance generator.

We have integrated automatic derivation of an instance generator, from an example, into the Derive tool. In order to specify a new instance generator, the user can \textit{either} specify a derivation function, \textit{or} have one automatically generated from an example.


\section{Automatic Instance Generator Derivation}
\label{sec:automatic_instances}

This section describes how to derive an instance generator, given an example instance. There are four key concepts in our task: \S\ref{sec:generation} generating and testing a hypothesis; \S\ref{sec:environment} the environment in which a hypothesis exists; \S\ref{sec:induction} induction on lists; \S\ref{sec:folds} induction on folds.

\subsection{Hypothesis Generation and Testing}
\label{sec:generation}

The idea behind hypothesis generation is that given a value, a hypothesis determines both an environment, and a mapping from an environment to the original value. An environment captures the aspects that are particular to a data type, and would change given a different data type. This technique of introducing an environment allows the hypothesis to be parameterised by the data type.

In order to guess a data type |tau|, we can define the following data types and function:

\begin{code}
data Env = ... -- see \ref{sec:environment}
data Hypothesis tau = Hypothesis Env (Env -> tau) String

guess :: tau -> [Hypothesis tau]
\end{code}

The |guess| function takes a value of type |tau|, and returns a list of hypotheses. Each hypothesis is an environment in which the value was found, a function to construct the value given an environment, and a string representing of the instance generator. Applying the returned environment to the value generator should return the original value.


\subsection{The Enclosing Environment}
\label{sec:environment}

An environment represents the parameterisable aspects of a hypothesis. There are three different types of environment. The empty environment provides a value which is constant. The constructor environment uses information from a particular constructor -- for example the constructor name, the arity or the 0-based index. The field environment provides the index of a field within a constructor. The |Env| data type is defined as:

\begin{code}
data Env = Empty | Ctor Int | Field Int
\end{code}

For each terminal value in the syntax tree, an environment is produced, which generates the value. If the name |CtorOne| was encountered this would be assigned the environment |Ctor 1| -- being the constructor name for the appropriate constructor. If the name |True| was encountered the environment would be |Empty| -- no constructors or fields relate to the value |True|. If a terminal ends in a number, i.e. |x1|, then the number is separately assigned an environment. 

\begin{figure}[t]
\begin{code}
guessNum :: Int -> [Env]
guessNum i  =        [Field i  | i `elem` [1..2]  ]  -- a field
            `union`  [Empty    | i `elem` [3..4]  ]  -- the number of constructors
            `union`  [Ctor i   | i `elem` [0..3]  ]  -- the constructor index
            `union`  [Ctor i   | i `elem` [0..2]  ]  -- the constructor arity
            `union`  [Ctor 3   | i == 2           ]  -- the constructor arity
\end{code}
\caption{The function |guessNum|, which guesses an environment from a number.}
\label{fig:guessnum}
\end{figure}

The terminal with most possible environments is a number. Take for instance the number 2 -- within |DataName| (Figure \ref{fig:dataname}) this could correspond to the field in position 2, the arity of |CtorTwo| or |CtorTwo'|, the index of |CtorTwo|, or simply a constant. The code to guess the environment from a number is given in Figure \ref{fig:guessnum}. A list of many possible environments is returned, allowing many possible hypotheses to be generated for a single terminal.


\subsection{List Induction on Environments}
\label{sec:induction}

GOT TO HERE

For most types, |guess| can be simply defined as guessing all the sub-components, then combining them back together. The one exception to this is a list. The list induction property relies on the ordering of environments. All the constructors may be present in a none environment. The appropriate fields may be present in a constructor environment. The idea can best be expressed with an example. Given the list whose environments are |[Field 1, Field 2]|, we can generalise this to the environment |Ctor 2| or |Ctor 3| -- assuming that the actual meaning is that all fields are present. This generalisation can then be applied to |Ctor 0| generating an empty list.

To generate an enclosing environment, all possible combinations of environments are examined. Once a particular set of environments is available, they are all checked against all hypotheses that are present. If there is a particular hypothesis that satisfies all the elements of this list, it is promoted to a hypothesis on its enclosing environment.

This list induction does the majority of the work, and is responsible for the inductive instances. By localising this induction principle to lists, we are able to induct over almost any aspect of a data structure. This gives a lot of power.

\subsection{Fold Induction on Environments}
\label{sec:folds}

One common pattern in instance definitions is the \textit{fold}. Consider the |Eq| example from before. If we move to using prefix notation for |(&&)| and explicit bracketing we obtain:

\begin{code}
(CtorTwo x1 x2) == (CtorTwo y1 y2) = (&&) (x1 == y1) ((&&) (x2 == y2) True)
\end{code}

This structure is not a list, and would not be inductively found by the list guess mechanism. However, we can see this as a fold. A fold takes a list, and replaces each join in the list by a function -- in this case |(&&)|. By spotting this fold pattern, it can be reversed to allow us to express it as a left fold, with |(&&)| as the combining element, and |True| as the root.

This aspect also explains the redundant |&& True| at the end -- in order for the base case (|True|) to share the same fold pattern as the above case, we require a dummy argument in this one. In the code generated for instances this dummy operation will be removed, by using algebraic simplification provided by Derive.


\section{Failures of Automatic Derivation}
\label{sec:automatic_failure}

We have now defined a mechanism for inductive instances, the question now arises as to which instances can be automatically derived, and which ones must be written manually. Of the 24 instances provided by the Derive tool, 15 are able to be written by example, and 9 require hand-coding. There are several reasons for the automatic method to be inappropriate, which we list here:

\subsection{Non-inductive definitions}

One reason is that the definition does not follow inductively. Take for example the case of serialising a value to disk, which is achieved in Haskell using the |Binary| class. For a data type with one constructor, no tag needs to be written. For a data structure with less than 256 constructors, a single byte is written to indicate which constructor was encountered. For greater numbers of constructors, a larger sized tag must be given. These instances are not inductive -- the change from 1 constructor to 2 does not follow the same pattern.

\subsection{Type-based definitions}

Some definitions require knowledge of the type, for example the |Monoid| instance requires items of the same type to be written using |mappend|, but items of a different type to be |mempty|. The relationship between a type and the instance can be arbitrarily complex, and is required to derive |Play| and |Functor|.

\subsection{Record-based definitions}

Haskell provides a method for records, taking the |Degree| example:

\begin{code}
data Degree = MSc | PhD {years :: Int}
\end{code}

This automatically generates functions to retrieve and modify the |years| field within |PhD|. Some classes are defined which test whether a constructor has a particular field, and extract the relevant field. These cannot be automatically inferred.

Fortunately, even with these restrictions, the majority of classes can be defined in a manner which allows the automatic derivation to succeed.

\section{Successes of Generation}
\label{sec:automatic_success}

In this section we present a small number of successful examples, taken from various papers, including the example instance.


\subsection{The Data class}

The |Data| class was introduced in Scrap Your Boilerplate, and allows Haskell programmers to make use of short traversals and queries, even over complex data structures. The fundamental operation is |gfoldl|:

\begin{code}
instance (Data alpha, Typeable alpha) => Data (DataName alpha) where
    gfoldl k r (CtorZero         )= r CtorZero
    gfoldl k r (CtorOne   x1     ) = r CtorOne   `k` x1
    gfoldl k r (CtorTwo   x1 x2  ) = r CtorTwo   `k` x1 `k` x2
    gfoldl k r (CtorTwo'  x1 x2  ) = r CtorTwo'  `k` x1 `k` x2
\end{code}

Here the instances involve a fold over one data value, and the application of an argument to join the fields. This is all dealt with by the instance generator.

\subsection{The Serial class}

The |Serial| class is used by SmallCheck to automatically perform enumerative testing over Haskell programs. The definition relies on the arities of each constructor, and does not induct over the field names.

\begin{code}
instance Serial alpha => Serial (DataName alpha) where
    series = cons0 CtorZero \/ cons1 CtorOne  \/ cons2 CtorTwo  \/ cons2 CtorTwo'
\end{code}

Once again, the inductive instances are able to automatically generate the required code.

\section{Related Work}
\label{sec:related}

Cite genetic algorithms.

Discuss how this scheme can be adapted to other contexts.

Proof system, by making induction.


\section{Conclusion and Future Work}
\label{sec:conclusion}

We have presented a mechanism for automatically deriving instances for Haskell programs. Using our scheme, even a novice programmer, with no experience of the Derive framework, is able to define many classes they encounter simply by supplying examples. By removing the overhead of learning a new library, the number of potential users increases massively.

Now that the computer is able to infer the rules required for constructing a type, the information never needs to be expressed again, even if the API's should change. This also leads to the advantage that alternative definitions could be given -- for example using Haskell's reflection capabilities instances could be derived at run-time, removing all overhead of separate preprocessors.


\bibliographystyle{plain}
\bibliography{derive}

\end{document}
