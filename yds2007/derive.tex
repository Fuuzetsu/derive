% Note:
% I'm thinking of submitting this to the York Doctoral Symposium
% http://www.cs.york.ac.uk/yds/
%
% Perhaps after it could be revamped as a The Monad.Reader article
% with more on the Derive side of things?

\documentclass{llncs}

\usepackage{url}

%include polycode.fmt
%include derive.fmt

\begin{document}

\title{Deriving Inductive Instances by Example}
\author{Neil Mitchell}

\institute{University of York, UK\\
\url{http://www.cs.york.ac.uk/~ndm/}}

\maketitle

\begin{abstract}
For certain functions, the implementation is dependent on the structure of the data type upon which it operates. In some cases, it is possible to automatically infer the relationship between the data type and the code, merely by looking at a single example. This paper presents a mechanism for such an inference scheme.

In Haskell, a type-class defines an operation which is parameterised by the data type. This pattern is common, and often can be computed by automatic inference. We have implemented such as scheme in the Derive tool, allowing over 60\% of instances to be inferred.
\end{abstract}

\section{Introduction}

Haskell contains a type-class mechanism, to allow similar operations to be defined on different data structures. One such type class is |Eq|, defined as:

\begin{code}
class Eq alpha where
    (==) :: alpha -> alpha -> Bool
\end{code}

This classs says that the |(==)| operator (equality) is defined for all types which have an |Eq| instance. We can define a Haskell data type, and an instance for |Eq| as:

\begin{code}
data Degree  =  MSc        -- someone doing an MSc
             |  PhD Int    -- PhD student, plus year of study

instance Eq Degree where
    (MSc    )  == (MSc    )  = True
    (PhD x  )  == (PhD y  )  = x == y
    _          == _          = False
\end{code}

The data type we introduce is |Degree|. A value of type |Degree| can be constructed by either |MSc|, or |PhD|. A |PhD| includes an integer field which records the year of study. We can define an |Eq| instance as above. The first line says that any two |MSc| values are equal. The second line says that for two |PhD| values to be equal, they must have the same year inside them. The final line says that for any remaining pairs of values, they are not equal.

The standard instance of |Eq| follows naturally from a data structure -- if two values have the same constructor, and have equal fields, then they are equal -- otherwise they are not. This relationship is a function from a data structure, to a fragment of code. So how can a user express this relationship? Using inductive instance generation, as described in this paper, they can simply write a single example instance on the provided |DataName| type:

\begin{code}
data DataName alpha  =  CtorZero
                     |  CtorOne   alpha
                     |  CtorTwo   alpha alpha
                     |  CtorTwo'  alpha alpha

instance Eq alpha => Eq (DataName alpha) where
    (CtorZero         )  == (CtorZero         )  = True
    (CtorOne   x1     )  == (CtorOne   y1     )  = x1 == y1 && True
    (CtorTwo   x1 x2  )  == (CtorTwo   y1 y2  )  = x1 == y1 && x2 == y2 && True
    (CtorTwo'  x1 x2  )  == (CtorTwo'  y1 y2  )  = x1 == y1 && x2 == y2 && True
    _                    == _                    = False
\end{code}

From this example, the instance generation makes several \textit{hypothesises} as to the relationship between the data structure and the code, then \textit{tests} each hypothesis to find one which matches. With a valid hypothesis, the generator writes out a function which takes as input a data structure, and returns Haskell code.

\subsection{Roadmap}

This paper first describes how manual instances must be written in \S0, including their disadvantages. In \S0 we look at how automatic hypothesises are generated and tested. \S0 look at which instances are applicable for this scheme, describing why some are not. \S0 presents related work, and \S0 concludes.


\section{Generating Instances}

There are currently three mechanisms for generating new instances automatically -- each with disadvantages. We first discuss each briefly.

\subsection{Built in |deriving|}

The |Eq| instance given above could have been automatically derived by the compiler, simply by adding |deriving Eq| at the end of the data structure. Unfortunately the addition of a |deriving| statement must be made at the same place as the declaration of the data structure -- if the declaration is in a library then the user of the library cannot add a |deriving|. The deriving mechanism is also provided only for six inbuilt Haskell classes, with no way to extend it further.

\subsection{The DrIFT tool}

A mechanism to derive additional classes was provided initially by DrIFT. By making annotations in the source code the DrIFT tool generates additional code, which can be appended to the current file. The DrIFT tool is limited to a fixed number of predetermined derivations, and while these can be added to, they require a modification to DrIFT itself. The DrIFT method also requires a preprocessor to be run on all files.

The DrIFT approach to writing instances is to have a data structure representing the layout of data structures, with appropriate methods to query its structure. The author of an instance then manually writes a function that transforms from this input, to a Haskell code fragment produced using a pretty-printing combinator library. The author must become familiar with both the description of the data structure, and with the pretty-printers and additional functions required by DrIFT.

\subsection{The Derive tool}

A successor to DrIFT is the Derive tool. This tool handles more Haskell extensions, and is designed to allow the end user to add new instance derivations external to the tool. On the GHC compiler the derivations can be performed at compile time automatically -- without the need for a preprocessor. The way this is achieved is by making use of Template Haskell. Template Haskell allows the programmer to generate a syntax tree at compile time, which is spliced into the code being compiled. The Derive machinery takes care of many of the Template Haskell details, leaving the author of an instance to write a function from a data structure to a Haskell syntax tree.

Unfortunately, the Haskell syntax tree is quite a large data type, and has a reasonably sharp learning curve. In order to write an instance generator requires lots of thought, and lots of examination of API's. While this approach has proved successful, it is still a barrier to entry to some users. This approach also requires some significant effort in testing that instances match their intended behaviour, and it is time consuming to add new instances.

We have integrated our automatic instance derivation into the Derive tool, allow a user to either specify their derivation function, or have one automatically generated. To the user of the instance generator, there is no difference. To the author, the time saving can be considerable!


\section{Automatic Derivation}

The concept behind automatic derivation is that the code generated from a data structure must be \textit{inductive}. As additional constructors or fields are added, the code must expand in a standardised way. This insight then leads to the realisation that the hypothesis must look for these inductive patterns, and exploit them. There are four key concepts in our task: (1) generating and testing a hypothesis; (2) the environment in which a hypothesis exists; (3) induction on lists; (4) folds as lists.

\subsection{Generation and Testing}

In order to guess a data type |tau|, we can define the following data types and function:

\begin{code}
data Env = ... -- see later
type Hypothesis tau = Hypothesis Env (Env -> tau) String

guess :: tau -> [Hypothesis tau]
\end{code}

The |guess| function takes a value of type |tau|, and returns a list of hypothesises. Each hypothesis is an environment in which the value was found, a function to construct the value given an environment, and a string representing the code this represents. The idea is that given the current environment, the original value should be returned. The |guess| function returns a list of all hypothesises it thinks could be appropriate -- all must be appropriate to this particular value, but in a wider context only one may be correct.

\subsection{Environments}

The key idea in instance generation is an environment. An environment is defined as:

\begin{code}
data Env = None | Ctor Int | Field Int
\end{code}

The idea is that each term in the code either relates to the constructor that is being examined, the field, or is constant. For example, when encountering |CtorOne| the environment would be |Ctor 1|. When encountering the constant |True|, the environment would be |None|.

The idea of an environment is that it allows a particular fragment to be parameterised by something, which allows a new fragment to be generated as the environment changes. The key idea is that when finding a constant, the program searches for a possible environment which matches. For example, upon finding a number the environment can be calculated as follows:

\begin{code}
guessNum :: Int -> [Env]
guessNum i  =        [Field i  | i `elem` [1..2]  ]  -- a field
            `union`  [None     | i `elem` [1..2]  ]  -- the number of constructors
            `union`  [Ctor i   | i `elem` [0..3]  ]  -- the constructor index
            `union`  [Ctor i   | i `elem` [0..2]  ]  -- the constructor arity
            `union`  [Ctor 3   | i == 2           ]  -- the constructor arity
\end{code}

Here if the number 2 is found, it could be the second field, the constructor at index 2 (|CtorTwo|), the arity of |CtorTwo|, or the arity of |CtorTwo'|. By returning many possible environments, the program can pick the appropriate one afterwards -- with full knowledge of all other items.

\subsection{Induction on Environments}

For most types, |guess| can be simply defined as guessing all the sub-components, then combining them back together. The one exception to this is a list. The list induction property relies on the ordering of environments. All the constructors may be present in a none environment. The appropriate fields may be present in a constructor environment. The idea can best be expressed with an example. Given the list whose environments are |[Field 1, Field 2]|, we can generalise this to the environment |Ctor 2| or |Ctor 3| -- assuming that the actual meaning is that all fields are present. This generalisation can then be applied to |Ctor 0| generating an empty list.

To generate an enclosing environment, all possible combinations of environments are examined. Once a particular set of environments is available, they are all checked against all hypotheses that are present. If there is a particular hypothesis that satisfies all the elements of this list, it is promoted to a hypothesis on its enclosing environment.

This list induction does the majority of the work, and is responsible for the inductive instances. By localising this induction principle to lists, we are able to induct over almost any aspect of a data structure. This gives a lot of power.

\subsection{Inductive Folds}

One common pattern in instance definitions is the \textit{fold}. Consider the |Eq| example from before. If we move to using prefix notation for |(&&)| and explicit bracketing we obtain:

\begin{code}
(CtorTwo x1 x2) == (CtorTwo y1 y2) = (&&) (x1 == y1) ((&&) (x2 == y2) True)
\end{code}

This structure is not a list, and would not be inductively found by the list guess mechanism. However, we can see this as a fold. A fold takes a list, and replaces each join in the list by a function -- in this case |(&&)|. By spotting this fold pattern, it can be reversed to allow us to express it as a left fold, with |(&&)| as the combining element, and |True| as the root.

This aspect also explains the redundant |&& True| at the end -- in order for the base case (|True|) to share the same fold pattern as the above case, we require a dummy argument in this one. In the code generated for instances this dummy operation will be removed, by using algebraic simplification provided by Derive.


\section{Failures of Automatic Derivation}

We have now defined a mechanism for inductive instances, the question now arises as to which instances can be automatically derived, and which ones must be written manually. Of the 24 instances provided by the Derive tool, 15 are able to be written by example, and 9 require hand-coding. There are several reasons for the automatic method to be inappropriate, which we list here:

\subsection{Non-inductive definitions}

One reason is that the definition does not follow inductively. Take for example the case of serialising a value to disk, which is achieved in Haskell using the |Binary| class. For a data type with one constructor, no tag needs to be written. For a data structure with less than 256 constructors, a single byte is written to indicate which constructor was encountered. For greater numbers of constructors, a larger sized tag must be given. These instances are not inductive -- the change from 1 constructor to 2 does not follow the same pattern.

\subsection{Type-based definitions}

Some definitions require knowledge of the type, for example the |Monoid| instance requires items of the same type to be written using |mappend|, but items of a different type to be |mempty|. The relationship between a type and the instance can be arbitrarily complex, and is required to derive |Play| and |Functor|.

\subsection{Record-based definitions}

Haskell provides a method for records, taking the |Degree| example:

\begin{code}
data Degree = MSc | PhD {years :: Int}
\end{code}

This automatically generates functions to retrieve and modify the |years| field within |PhD|. Some classes are defined which test whether a constructor has a particular field, and extract the relevant field. These cannot be automatically inferred.

Fortunately, even with these restrictions, the majority of classes can be defined in a manner which allows the automatic derivation to succeed.

\section{Successes of Generation}

In this section we present a small number of successful examples, taken from various papers, including the example instance.


\subsection{The Data class}

The |Data| class was introduced in Scrap Your Boilerplate, and allows Haskell programmers to make use of short traversals and queries, even over complex data structures. The fundamental operation is |gfoldl|:

\begin{code}
instance (Data alpha, Typeable alpha) => Data (DataName alpha) where
    gfoldl k r (CtorZero         )= r CtorZero
    gfoldl k r (CtorOne   x1     ) = r CtorOne   `k` x1
    gfoldl k r (CtorTwo   x1 x2  ) = r CtorTwo   `k` x1 `k` x2
    gfoldl k r (CtorTwo'  x1 x2  ) = r CtorTwo'  `k` x1 `k` x2
\end{code}

Here the instances involve a fold over one data value, and the application of an argument to join the fields. This is all dealt with by the instance generator.

\subsection{The Serial class}

The |Serial| class is used by SmallCheck to automatically perform enumerative testing over Haskell programs. The definition relies on the arities of each constructor, and does not induct over the field names.

\begin{code}
instance Serial alpha => Serial (DataName alpha) where
    series = cons0 CtorZero \/ cons1 CtorOne  \/ cons2 CtorTwo  \/ cons2 CtorTwo'
\end{code}

Once again, the inductive instances are able to automatically generate the required code.

\section{Related Work}

Cite genetic algorithms.

Discuss how this scheme can be adapted to other contexts.

Proof system, by making induction.


\section{Conclusion and Future Work}

We have presented a mechanism for automatically deriving instances for Haskell programs. Using our scheme, even a novice programmer, with no experience of the Derive framework, is able to define many classes they encounter simply by supplying examples. By removing the overhead of learning a new library, the number of potential users increases massively.

Now that the computer is able to infer the rules required for constructing a type, the information never needs to be expressed again, even if the API's should change. This also leads to the advantage that alternative definitions could be given -- for example using Haskell's reflection capabilities instances could be derived at run-time, removing all overhead of separate preprocessors.

\end{document}
